<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fren Finder - Advanced Nostr Discovery</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #faf8f5;
            --bg-secondary: #f0ede7;
            --bg-tertiary: #e8e3da;
            --text-primary: #1a1512;
            --text-secondary: #5a524a;
            --text-tertiary: #8a7f72;
            --accent-primary: #c84e3a;
            --accent-secondary: #2d5f4f;
            --accent-success: #2d7a4f;
            --accent-info: #3a6ea5;
            --border-color: #d4cec2;
            --shadow-color: rgba(26, 21, 18, 0.08);
            --transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1512;
            --bg-secondary: #2a2319;
            --bg-tertiary: #3a3229;
            --text-primary: #faf8f5;
            --text-secondary: #c4beb4;
            --text-tertiary: #8a7f72;
            --accent-primary: #e8745e;
            --accent-secondary: #4a9276;
            --accent-success: #4a9a70;
            --accent-info: #5a8ec5;
            --border-color: #3a3229;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            transition: var(--transition);
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        header {
            padding: 3rem 0 2rem;
            border-bottom: 1px solid var(--border-color);
            animation: fadeInDown 0.6s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .logo-section h1 {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: var(--transition);
            font-weight: 600;
            border: none;
        }

        .btn-login {
            background: var(--accent-primary);
            color: var(--bg-primary);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .btn-logout {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .theme-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .theme-toggle:hover, .btn-logout:hover {
            background: var(--bg-tertiary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        main {
            padding: 3rem 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .search-section {
            margin-bottom: 3rem;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }

        input[type="text"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .discovery-mode {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .mode-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
        }

        .mode-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .mode-card.active {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            box-shadow: 0 4px 16px var(--shadow-color);
        }

        .mode-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .mode-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        select {
            padding: 0.875rem 1.25rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition);
        }

        select:focus {
            outline: none;
            border-color: var(--accent-secondary);
        }

        .btn-primary {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 1rem;
        }

        .results-header h2 {
            font-size: 2rem;
            font-weight: 600;
        }

        .results-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .results-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .sort-dropdown {
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .fren-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    padding: 1.75rem;
    transition: var(--transition);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

        .fren-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-primary);
            transform: scaleY(0);
            transition: var(--transition);
        }

        .fren-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .fren-card:hover::before {
            transform: scaleY(1);
        }

        .fren-card.already-following {
            opacity: 0.6;
            background: var(--bg-tertiary);
        }

        .fren-card.already-following:hover {
            opacity: 0.8;
        }

        .fren-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .fren-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
            flex-shrink: 0;
        }

        .fren-info {
            flex: 1;
            min-width: 0;
        }

        .fren-name {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .fren-npub {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: var(--transition);
            padding: 0.25rem;
            border-radius: 0.25rem;
        }

        .fren-npub:hover {
            color: var(--accent-primary);
        }

        .match-score {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            padding: 0.4rem 0.8rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .fren-bio {
            color: var(--text-secondary);
            margin-bottom: 1.25rem;
            font-size: 1rem;
            line-height: 1.6;
        }

        .metrics-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .metric-badge {
            background: var(--bg-tertiary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .metric-badge.high {
            background: var(--accent-success);
            color: var(--bg-primary);
            border-color: var(--accent-success);
        }

        .metric-badge.medium {
            background: var(--accent-info);
            color: var(--bg-primary);
            border-color: var(--accent-info);
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .tag {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
        }

        .fren-actions {
    display: flex;
    gap: 0.75rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
    margin-top: auto;
}

        .btn-follow {
            flex: 1;
            padding: 0.75rem;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .btn-follow:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-follow:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-follow.following {
            background: var(--accent-success);
        }

        .btn-view-profile {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            color: var(--text-primary);
            display: inline-block;
        }

        .btn-view-profile:hover {
            background: var(--bg-secondary);
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        footer {
            border-top: 1px solid var(--border-color);
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
            color: var(--text-tertiary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .toggle-group {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background-color: var(--bg-primary);
        }

        .toggle-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .already-following-section {
            margin-top: 3rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .following-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .following-header h3 {
            font-size: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .following-count {
            background: var(--accent-info);
            color: var(--bg-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .following-toggle-icon {
            font-size: 1.5rem;
            transition: var(--transition);
        }

        .following-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .following-content {
            display: none;
            padding-top: 1.5rem;
        }

        .following-content.visible {
            display: block;
        }

        .hashtag-search-container {
            display: none;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 0.75rem;
        }

        .hashtag-search-container.visible {
            display: block;
        }

        .hashtag-input-wrapper {
            position: relative;
            margin-bottom: 1rem;
        }

        .hashtag-input {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .hashtag-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .hashtag-input::placeholder {
            color: var(--text-tertiary);
        }

        .tag-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 10;
        }

        .tag-suggestions.visible {
            display: block;
        }

        .tag-suggestion-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }

        .tag-suggestion-item:hover {
            background: var(--bg-secondary);
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            min-height: 2.5rem;
        }

        .selected-tag {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2rem;
            line-height: 1;
        }

        .tag-remove:hover {
            transform: scale(1.2);
        }

        .match-mode-toggle {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .match-mode-btn {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            font-weight: 600;
        }

        .match-mode-btn.active {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .match-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .popular-tags {
            margin-top: 1rem;
        }

        .popular-tags-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .popular-tags-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .popular-tag {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .popular-tag:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .cross-reference-container {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .cross-ref-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cross-ref-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .cross-ref-toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
        }

        .cross-ref-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .cross-ref-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .cross-ref-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider {
            background-color: var(--accent-info);
            border-color: var(--accent-info);
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider:before {
            transform: translateX(18px);
            background-color: var(--bg-primary);
        }

        .cross-ref-input {
            width: 100%;
            padding: 0.875rem 1.25rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            transition: var(--transition);
            display: none;
        }

        .cross-ref-input.visible {
            display: block;
        }

        .cross-ref-input:focus {
            outline: none;
            border-color: var(--accent-info);
        }

        .comparison-results {
            margin-top: 2rem;
            display: none;
        }

        .comparison-results.visible {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .comparison-category {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .comparison-category h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            color: var(--accent-info);
        }

        .comparison-count {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .comparison-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .bunker-login-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            padding: 2rem;
            overflow-y: auto;
        }

        .bunker-login-modal.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bunker-login-content {
            background: var(--bg-primary);
            border: 2px solid var(--accent-info);
            border-radius: 0.75rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }

        .bunker-login-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }

        .bunker-login-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-info);
        }

        .bunker-close {
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .bunker-close:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .bunker-instructions {
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .bunker-instructions ol {
            text-align: left;
            padding-left: 1.5rem;
            margin-top: 1rem;
        }

        .bunker-instructions li {
            margin-bottom: 0.5rem;
        }

        .qr-code-container {
            background: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1.5rem auto;
            max-width: 300px;
        }

        .bunker-connection-string {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            word-break: break-all;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            max-height: 100px;
            overflow-y: auto;
        }

        .bunker-status {
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .bunker-status.waiting {
            color: var(--accent-info);
        }

        .bunker-status.connected {
            color: var(--accent-success);
        }

        .bunker-status.error {
            color: var(--accent-primary);
        }

        .btn-bunker {
            background: var(--accent-info);
            color: var(--bg-primary);
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 2rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(58, 110, 165, 0.2);
            transition: var(--transition);
        }

        .btn-bunker:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(58, 110, 165, 0.3);
        }

        .login-dropdown {
            position: relative;
        }

        .login-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            box-shadow: 0 8px 24px var(--shadow-color);
            z-index: 100;
            min-width: 200px;
        }

        .login-menu.visible {
            display: block;
        }

        .login-option {
            padding: 0.875rem 1.25rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
        }

        .login-option:last-child {
            border-bottom: none;
        }

        .login-option:hover {
            background: var(--bg-secondary);
        }

        @media (max-width: 768px) {
            .logo-section h1 { font-size: 2.5rem; }
            .header-content { flex-direction: column; }
            .filter-row { grid-template-columns: 1fr; }
            .results-grid { grid-template-columns: 1fr; }
            .discovery-mode { grid-template-columns: 1fr; }
            .toggle-group { flex-direction: column; gap: 1rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="logo-section">
                    <h1>Fren Finder</h1>
                    <p class="subtitle">Advanced Nostr Discovery</p>
                </div>
                <div class="header-actions">
                    <div id="user-section"></div>
                    <button class="btn theme-toggle" id="theme-btn">Toggle Theme</button>
                </div>
            </div>
        </header>

        <main>
            <section class="search-section">
                <div class="input-group">
                    <label for="npub-input">Your Nostr Public Key</label>
                    <input type="text" id="npub-input" placeholder="npub1... (or click Login)">
                </div>

                <div class="cross-reference-container">
                    <div class="cross-ref-toggle">
                        <label class="cross-ref-toggle-switch">
                            <input type="checkbox" id="enable-cross-ref">
                            <span class="cross-ref-toggle-slider"></span>
                        </label>
                        <div class="cross-ref-label">
                            Cross-Reference With Another Account
                        </div>
                    </div>
                    <input type="text" 
                           class="cross-ref-input" 
                           id="cross-ref-input" 
                           placeholder="Enter another npub to compare networks">
                    
                    <div class="comparison-results" id="comparison-results">
                        <div class="comparison-category">
                            <h4>You Follow</h4>
                            <div class="comparison-count" id="you-only-count">0</div>
                            <div class="comparison-desc">Accounts only you follow</div>
                        </div>
                        <div class="comparison-category">
                            <h4>Both Follow</h4>
                            <div class="comparison-count" id="mutual-count">0</div>
                            <div class="comparison-desc">Shared connections</div>
                        </div>
                        <div class="comparison-category">
                            <h4>They Follow</h4>
                            <div class="comparison-count" id="them-only-count">0</div>
                            <div class="comparison-desc">Accounts only they follow</div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Discovery Mode</label>
                    <div class="discovery-mode">
                        <div class="mode-card active" data-mode="social">
                            <div class="mode-title">Social Graph</div>
                            <div class="mode-desc">Friends of friends</div>
                        </div>
                        <div class="mode-card" data-mode="interests">
                            <div class="mode-title">Shared Interests</div>
                            <div class="mode-desc">Hashtag matching</div>
                        </div>
                        <div class="mode-card" data-mode="niche">
                            <div class="mode-title">Niche Communities</div>
                            <div class="mode-desc">Specific topics</div>
                        </div>
                        <div class="mode-card" data-mode="hashtags">
                            <div class="mode-title">Hashtag Discovery</div>
                            <div class="mode-desc">Search by tags</div>
                        </div>
                    </div>
                </div>

                <div class="hashtag-search-container" id="hashtag-search">
                    <div class="hashtag-input-wrapper">
                        <input type="text" 
                               class="hashtag-input" 
                               id="hashtag-input" 
                               placeholder="Enter hashtags (e.g., bitcoin, nostr, photography)">
                        <div class="tag-suggestions" id="tag-suggestions"></div>
                    </div>

                    <div class="selected-tags" id="selected-tags"></div>

                    <div class="match-mode-toggle">
                        <button class="match-mode-btn active" id="match-any">Match ANY Tag</button>
                        <button class="match-mode-btn" id="match-all">Match ALL Tags</button>
                    </div>

                    <div class="popular-tags">
                        <div class="popular-tags-label">Popular Tags</div>
                        <div class="popular-tags-grid" id="popular-tags"></div>
                    </div>
                </div>

                <div class="toggle-group">
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-spam" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide Spam</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-nsfw" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide NSFW</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-following" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide Already Following</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="recent-activity-only" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Posted Within a Month</span>
    </div>
</div>

                <div class="filter-row">
                    <div class="input-group">
                        <label for="min-followers">Min Network Size</label>
                        <select id="min-followers">
                            <option value="0">Any Size</option>
                            <option value="10">Small (10+)</option>
                            <option value="50">Medium (50+)</option>
                            <option value="100">Large (100+)</option>
                            <option value="500">Very Large (500+)</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="activity-level">Activity Level</label>
                        <select id="activity-level">
                            <option value="any">Any Activity</option>
                            <option value="high">Very Active</option>
                            <option value="medium">Moderately Active</option>
                            <option value="low">Occasional</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="result-count">Results</label>
                        <select id="result-count">
                            <option value="10">10 Profiles</option>
                            <option value="25">25 Profiles</option>
                            <option value="50">50 Profiles</option>
                        </select>
                    </div>
                </div>

                <button class="btn-primary" id="find-btn">Discover Frens</button>
            </section>

            <div class="bunker-login-modal" id="bunker-login-modal">
                <div class="bunker-login-content">
                    <div class="bunker-login-header">
                        <h3>Remote Signer Login</h3>
                        <span class="bunker-close" id="close-bunker">×</span>
                    </div>
                    <div class="bunker-instructions">
                        <p><strong>Instructions for Remote Signing:</strong></p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>For Amber (Android):</strong><br>
                            1. Open Amber app<br>
                            2. Tap "Connect Application"<br>
                            3. Scan QR code or paste connection string<br>
                            4. Approve the connection
                        </p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>For Nsec.app:</strong><br>
                            1. Go to nsec.app on mobile<br>
                            2. Tap "Connect"<br>
                            3. Scan QR code<br>
                            4. Approve permissions
                        </p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>Manual Setup:</strong><br>
                            Copy the connection string below and paste into your signing app
                        </p>
                    </div>
                    <div class="qr-code-container" id="qr-code-container"></div>
                    <div class="bunker-connection-string" id="bunker-connection-string"></div>
                    <button class="btn-primary" id="copy-connection-btn" style="margin-top: 1rem; display: none;">
                        Copy Connection String
                    </button>
                    <div class="bunker-status waiting" id="bunker-status">Waiting for connection...</div>
                </div>
            </div>

            <section class="results-section" id="results-section">
                <div class="results-header">
    <h2>Discovered Frens</h2>
    <div class="results-info">
        <span class="results-count" id="results-count">0 matches</span>
    </div>
</div>
                <div class="results-grid" id="results-grid"></div>

                <div class="already-following-section" id="following-section" style="display: none;">
                    <div class="following-header" id="following-header">
                        <h3>People You Already Follow</h3>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span class="following-count" id="following-count">0</span>
                            <span class="following-toggle-icon" id="following-icon">▼</span>
                        </div>
                    </div>
                    <div class="following-content" id="following-content">
                        <div class="results-grid" id="following-grid"></div>
                    </div>
                </div>
            </section>

            <section id="empty-state" class="empty-state">
                <h3>Discover Your Nostr Community</h3>
                <p>Choose a discovery mode and find people based on multiple matching signals</p>
            </section>
        </main>

        <footer>
            <p>Fren Finder - Advanced Discovery for Nostr</p>
        </footer>
    </div>

   <script type="module">
  import * as NostrTools from "https://esm.sh/nostr-tools@2.7.2";
  import * as nip46 from "https://esm.sh/nostr-tools@2.7.2/nip46";

  window.NostrTools = { ...NostrTools, nip46 };
</script>
<script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>

<script>
        const profileCache = new Map();  
        const noteCache = new Map();
        let currentUser = null;
        let userFollowing = new Set();
        let discoveryMode = 'social';
        let bunkerConnection = null;
        let bunkerPubkey = null;

        

        window.addEventListener('load', async function() {
    // Timeout helper for mobile performance ← ✅ Added!
    function withTimeout(promise, ms, errorMsg) {
        return Promise.race([
            promise,
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error(errorMsg)), ms)
            )
        ]);
    }
    
    if (typeof NostrTools === 'undefined') {
        alert('Failed to load Nostr tools');
        return;
    }

            const { nip19, SimplePool } = NostrTools;
            const pool = new SimplePool();
            window._nostrPool = pool;
            
            const RELAYS = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://purplepag.es', 'wss://nostr.wine'];

            // Theme toggle
            document.getElementById('theme-btn').addEventListener('click', () => {
                const html = document.documentElement;
                const theme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                html.setAttribute('data-theme', theme);
                localStorage.setItem('theme', theme);
            });
            document.documentElement.setAttribute('data-theme', localStorage.getItem('theme') || 'light');

            // Spam detection function
            function detectSpam(profile, notes) {
                let spamScore = 0;
                const name = (profile.name || '').toLowerCase();
                const about = (profile.about || '').toLowerCase();
                
                // Check for common spam phrases
                const spamPhrases = [
                    'hello world',
                    'test test',
                    'testing 123',
                    'this is a test',
                    'hello nostr',
                    'first post',
                    'new here'
                ];

                
                
                for (const phrase of spamPhrases) {
                    if (about.includes(phrase) && about.length < 50) {
                        spamScore += 30;
                    }
                }
                
                // Empty or very short bio
                if (about.length === 0) spamScore += 20;
                if (about.length > 0 && about.length < 10) spamScore += 15;
                
                // Suspicious name patterns
                if (name.match(/^user\d+$/i)) spamScore += 25;
                if (name.match(/^anon\d+$/i)) spamScore += 20;
                if (name === 'anon' || name === '') spamScore += 10;
                
                // No profile picture
                if (!profile.picture) spamScore += 10;
                
                // No recent activity
                if (notes && notes.length === 0) spamScore += 20;
                if (notes && notes.length === 1) spamScore += 10;
                
                // Very repetitive content
                if (notes && notes.length > 1) {
                    const contents = notes.map(n => n.content.toLowerCase());
                    const uniqueContents = new Set(contents);
                    if (uniqueContents.size < notes.length / 2) {
                        spamScore += 15;
                    }
                }
                
                return spamScore; // 0-100, higher = more likely spam
            }

            // NSFW detection function
            function detectNSFW(profile) {
                const about = (profile.about || '').toLowerCase();
                const name = (profile.name || '').toLowerCase();
                
                const nsfwTags = [
                    '#nsfw',
                    '#xxx',
                    '#adult',
                    '#18+',
                    '#porn',
                    '#onlyfans',
                    'nsfw',
                    '18+'
                ];
                
                for (const tag of nsfwTags) {
                    if (about.includes(tag) || name.includes(tag)) {
                        return true;
                    }
                }
                
                return false;
            }

            // Discovery mode selection
            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('active'));
                    this.classList.add('active');
                    discoveryMode = this.dataset.mode;
                    
                    // Show/hide hashtag search interface
                    const hashtagSearch = document.getElementById('hashtag-search');
                    if (discoveryMode === 'hashtags') {
                        hashtagSearch.classList.add('visible');
                    } else {
                        hashtagSearch.classList.remove('visible');
                    }
                });
            });

            // Hashtag discovery setup
            const selectedHashtags = new Set();
            let matchMode = 'any'; // 'any' or 'all'

            const POPULAR_TAGS = [
                'bitcoin', 'nostr', 'lightning', 'crypto', 'privacy',
                'art', 'photography', 'music', 'writing', 'design',
                'coding', 'tech', 'ai', 'web3', 'freedom',
                'travel', 'food', 'fitness', 'nature', 'coffee',
                'startup', 'business', 'marketing', 'trading', 'investing'
            ];

            const TAG_SUGGESTIONS = [
                'bitcoin', 'nostr', 'lightning', 'crypto', 'btc',
                'art', 'photography', 'music', 'artist', 'creative',
                'coding', 'developer', 'programming', 'tech', 'software',
                'design', 'ui', 'ux', 'web', 'frontend',
                'writing', 'author', 'blog', 'content', 'writer',
                'privacy', 'security', 'opensource', 'linux', 'decentralized',
                'travel', 'adventure', 'nature', 'hiking', 'outdoors',
                'food', 'cooking', 'recipe', 'chef', 'foodie',
                'fitness', 'health', 'yoga', 'running', 'gym',
                'gaming', 'game', 'gamer', 'esports', 'streamer',
                'business', 'startup', 'entrepreneur', 'founder', 'investing',
                'philosophy', 'science', 'history', 'education', 'learning'
            ];

            // Render popular tags
            function renderPopularTags() {
                const container = document.getElementById('popular-tags');
                container.innerHTML = '';
                POPULAR_TAGS.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'popular-tag';
                    tagEl.textContent = `#${tag}`;
                    tagEl.addEventListener('click', () => addHashtag(tag));
                    container.appendChild(tagEl);
                });
            }
            renderPopularTags();

            document.getElementById('match-any').addEventListener('click', function() {
    matchMode = 'any';
    document.querySelectorAll('.match-mode-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
});

document.getElementById('match-all').addEventListener('click', function() {
    matchMode = 'all';
    document.querySelectorAll('.match-mode-btn').forEach(b => b.classList.remove('active'));
    this.classList.add('active');
});

            // Add hashtag to selection
            function addHashtag(tag) {
                const normalized = tag.toLowerCase().replace(/^#/, '');
                if (!selectedHashtags.has(normalized)) {
                    selectedHashtags.add(normalized);
                    renderSelectedTags();
                }
                document.getElementById('hashtag-input').value = '';
                document.getElementById('tag-suggestions').classList.remove('visible');
            }

            // Need to add hashtag input handler
document.getElementById('hashtag-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        const tag = e.target.value.trim();
        if (tag) {
            addHashtag(tag);
        }
    }
});

            // Remove hashtag from selection
            function removeHashtag(tag) {
                selectedHashtags.delete(tag);
                renderSelectedTags();
            }

            // Render selected tags
            function renderSelectedTags() {
                const container = document.getElementById('selected-tags');
                container.innerHTML = '';
                
                if (selectedHashtags.size === 0) {
                    container.innerHTML = '<div style="color: var(--text-tertiary); font-style: italic;">No tags selected</div>';
                    return;
                }

                selectedHashtags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'selected-tag';
                    tagEl.innerHTML = `
                        #${tag}
                        <span class="tag-remove" onclick="removeHashtag('${tag}')">×</span>
                    `;
                    container.appendChild(tagEl);
                });
            }
            renderSelectedTags();

            // Make removeHashtag available globally
            window.removeHashtag = removeHashtag;

            // Cross-reference toggle
            let crossRefEnabled = false;
            let crossRefData = null;

            document.getElementById('enable-cross-ref').addEventListener('change', function() {
                crossRefEnabled = this.checked;
                const crossRefInput = document.getElementById('cross-ref-input');
                const comparisonResults = document.getElementById('comparison-results');
                
                if (crossRefEnabled) {
                    crossRefInput.classList.add('visible');
                } else {
                    crossRefInput.classList.remove('visible');
                    comparisonResults.classList.remove('visible');
                    crossRefData = null;
                }
            });

            // Analyze cross-reference when input changes
            document.getElementById('cross-ref-input').addEventListener('blur', async function() {
                const crossRefNpub = this.value.trim();
                
                if (!crossRefNpub || !crossRefNpub.startsWith('npub1')) {
                    return;
                }

                const mainNpub = document.getElementById('npub-input').value.trim();
                if (!mainNpub || !mainNpub.startsWith('npub1')) {
                    alert('Please enter your main npub first');
                    return;
                }

                try {
                    // Fetch both follow lists
                    const { data: mainPubkey } = nip19.decode(mainNpub);
                    const { data: crossPubkey } = nip19.decode(crossRefNpub);

                    const mainFollows = await fetchFollows(mainPubkey);
                    const crossFollows = await fetchFollows(crossPubkey);

                    // Calculate overlaps
                    const mainSet = new Set(mainFollows);
                    const crossSet = new Set(crossFollows);

                    const youOnly = mainFollows.filter(p => !crossSet.has(p));
                    const themOnly = crossFollows.filter(p => !mainSet.has(p));
                    const mutual = mainFollows.filter(p => crossSet.has(p));

                    // Store for later use
                    crossRefData = {
                        youOnly: youOnly,
                        themOnly: themOnly,
                        mutual: mutual
                    };

                    // Display comparison stats
                    document.getElementById('you-only-count').textContent = youOnly.length;
                    document.getElementById('mutual-count').textContent = mutual.length;
                    document.getElementById('them-only-count').textContent = themOnly.length;
                    document.getElementById('comparison-results').classList.add('visible');

                } catch (err) {
                    console.error('Cross-reference error:', err);
                    alert('Failed to analyze cross-reference');
                }
            });

            // Check for extension
            async function checkExtension() {
                return typeof window.nostr !== 'undefined';
            }

            // Login
            async function loginWithExtension() {
                if (typeof window.nostr === 'undefined') {
                    alert('Please install a Nostr browser extension (Alby, nos2x)');
                    return null;
                }

                try {
                    const pubkey = await window.nostr.getPublicKey();
                    const npub = nip19.npubEncode(pubkey);
                    const profile = await fetchProfile(pubkey);
                    currentUser = { pubkey, npub, profile };
                    const follows = await fetchFollows(pubkey);
                    userFollowing = new Set(follows);
                    updateUserUI();
                    document.getElementById('npub-input').value = npub;
                    document.getElementById('npub-input').disabled = true;
                    return npub;
                } catch (err) {
                    console.error('Login error:', err);
                    alert('Failed to login');
                    return null;
                }
            }

            function logout() {
                currentUser = null;
                userFollowing.clear();
                document.getElementById('npub-input').value = '';
                document.getElementById('npub-input').disabled = false;
                updateUserUI();
            }

            function updateUserUI() {
    const npubInput = document.getElementById('npub-input');

    if (currentUser && currentUser.npub) {
        npubInput.value = currentUser.npub;
        npubInput.disabled = true;
    } else {
        npubInput.value = '';
        npubInput.disabled = false;
    }

    const userSection = document.getElementById('user-section');

    if (currentUser) {
        const name = currentUser.profile?.name || 'Anon';
        const picture = currentUser.profile?.picture || 
            `https://robohash.org/${currentUser.pubkey}?set=set5`;
                    userSection.innerHTML = `
                        <div class="user-info">
                            <img src="${picture}" class="user-avatar" onerror="this.src='https://robohash.org/${currentUser.pubkey}?set=set5'">
                            <span>${name}</span>
                        </div>
                        <button class="btn btn-logout" id="logout-btn">Logout</button>
                    `;
                    document.getElementById('logout-btn').addEventListener('click', logout);
                } else {
                    userSection.innerHTML = `
                        <div class="login-dropdown">
                            <button class="btn btn-login" id="login-btn">Login</button>
                            <div class="login-menu" id="login-menu">
                                <div class="login-option" id="extension-login">Extension Login</div>
                                <div class="login-option" id="bunker-login-option">Remote Signer</div>
                            </div>
                        </div>
                    `;
                    
                    const loginBtn = document.getElementById('login-btn');
                    const loginMenu = document.getElementById('login-menu');
                    
                    loginBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        loginMenu.classList.toggle('visible');
                    });
                    
                    document.getElementById('extension-login').addEventListener('click', function() {
                        loginMenu.classList.remove('visible');
                        loginWithExtension();
                    });
                    
                    document.getElementById('bunker-login-option').addEventListener('click', function() {
                        loginMenu.classList.remove('visible');
                        showBunkerLogin();
                    });
                    
                    // Close menu when clicking outside
                    document.addEventListener('click', function() {
                        loginMenu.classList.remove('visible');
                    });
                }
            }

            function getClientSecretKeyBytes() {
  let hex = localStorage.getItem('bunker_client_secret_hex');
  if (!hex) {
    const sk = NostrTools.generateSecretKey(); // Uint8Array(32)
    hex = Array.from(sk).map(b => b.toString(16).padStart(2, '0')).join('');
    localStorage.setItem('bunker_client_secret_hex', hex);
  }
  return new Uint8Array(hex.match(/.{2}/g).map(b => parseInt(b, 16)));
}

function makeNostrConnectSecret() {
  const bytes = crypto.getRandomValues(new Uint8Array(32));
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

            // Bunker login using official BunkerSigner (same as Primal)
let bunkerSigner = null;
let bunkerAbortController = null;

async function showBunkerLogin() {
  const modal = document.getElementById('bunker-login-modal');
  const statusEl = document.getElementById('bunker-status');
  const qrContainer = document.getElementById('qr-code-container');
  const connectionStringEl = document.getElementById('bunker-connection-string');

  qrContainer.innerHTML = '';
  connectionStringEl.textContent = '';

  // 1) client keypair (persistent)
  const clientSecretKey = getClientSecretKeyBytes();
  const clientPubkey = NostrTools.getPublicKey(clientSecretKey);

  const relays = [
  'wss://relay.damus.io',
  'wss://relay.nsec.app',
  'wss://nostr.wine'
];

const secret = makeNostrConnectSecret();

const params = new URLSearchParams();
relays.forEach(r => params.append('relay', r));
params.append('secret', secret);
params.append('name', 'Fren Finder');

const connectionString =
  `nostrconnect://${clientPubkey}?${params.toString()}`;

  connectionStringEl.textContent = connectionString;

  // 3) render QR (keep your existing qrcode code)
  try {
    if (typeof qrcode !== 'undefined') {
      const qr = qrcode(0, 'L');
      qr.addData(connectionString);
      qr.make();

      const canvas = document.createElement('canvas');
      canvas.width = 200;
      canvas.height = 200;
      const ctx = canvas.getContext('2d');
      const cellSize = 200 / qr.getModuleCount();

      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, 200, 200);

      ctx.fillStyle = '#000000';
      for (let row = 0; row < qr.getModuleCount(); row++) {
        for (let col = 0; col < qr.getModuleCount(); col++) {
          if (qr.isDark(row, col)) {
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
          }
        }
      }

      qrContainer.appendChild(canvas);
    }
  } catch (err) {
    console.error('QR error:', err);
  }

  modal.classList.add('visible');
  statusEl.className = 'bunker-status waiting';
  statusEl.textContent = 'Scan with your signer app...';

  // copy button
  const copyBtn = document.getElementById('copy-connection-btn');
  copyBtn.style.display = 'block';
  copyBtn.textContent = 'Copy Connection String';
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(connectionString).then(() => {
      copyBtn.textContent = 'Copied!';
      setTimeout(() => (copyBtn.textContent = 'Copy Connection String'), 2000);
    });
  };

  // 4) wait for signer (IMPORTANT: use fromURI)
  await connectBunker(connectionString, clientSecretKey, statusEl);
}

async function connectBunker(connectionString, clientSecretKeyBytes, statusEl) {
  // Check if nip46 exists
  if (!NostrTools.nip46 || !NostrTools.nip46.BunkerSigner) {
    statusEl.className = 'bunker-status error';
    statusEl.textContent = 'Bunker not supported. Please use Extension Login.';
    console.error('NostrTools.nip46 not available');
    return;
  }

  const { BunkerSigner } = NostrTools.nip46;

  statusEl.className = 'bunker-status waiting';
  statusEl.textContent = 'Waiting for signer approval...';

  try {
    // Parse URL manually
    const url = new URL(connectionString);
    const remotePubkey = url.hostname || url.pathname.replace('//', '');
    const relays = url.searchParams.getAll('relay');
    const secret = url.searchParams.get('secret');

    console.log('Parsed connection:', { remotePubkey, relays, secret });

    if (!remotePubkey || relays.length === 0) {
      throw new Error('Invalid connection string format');
    }

    console.log('Creating BunkerSigner...');

    // Try the constructor directly
    bunkerSigner = new BunkerSigner(
      clientSecretKeyBytes,
      {
        pubkey: remotePubkey,
        relays: relays,
        secret: secret
      },
      window._nostrPool,
      {
        onauth: (url) => {
          console.log('Auth URL:', url);
          window.open(url, '_blank');
        }
      }
    );

    console.log('BunkerSigner created, calling connect() with 60s timeout...');

    // Add 60 second timeout
    const connectPromise = bunkerSigner.connect();
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Connection timeout after 60 seconds')), 60000)
    );

    await Promise.race([connectPromise, timeoutPromise]);

    console.log('Connected! Getting public key...');

    statusEl.className = 'bunker-status connected';
    statusEl.textContent = 'Connected! Getting your key...';

    const userPubkey = await bunkerSigner.getPublicKey();
    
    if (!userPubkey) {
      throw new Error('Failed to get public key from signer');
    }

    console.log('Got pubkey:', userPubkey);
    await completeBunkerLogin(userPubkey, bunkerSigner);

  } catch (err) {
    console.error('Bunker connection error:', err);
    statusEl.className = 'bunker-status error';
    
    if (err.message.includes('timeout')) {
      statusEl.textContent = 'Connection timeout. Make sure you approved in your signer app.';
    } else {
      statusEl.textContent = 'Connection failed: ' + err.message;
    }
  }
}

            async function completeBunkerLogin(userPubkey, signer) {
  try {
    const statusEl = document.getElementById('bunker-status');
    const input = document.getElementById('npub-input');

    statusEl.className = 'bunker-status connected';
    statusEl.textContent = 'Loading your profile...';

    const npub = NostrTools.nip19.npubEncode(userPubkey);
    const profile = await fetchProfile(userPubkey);

    statusEl.textContent = 'Loading your follows...';
    const follows = await fetchFollows(userPubkey);

    // ✅ set state FIRST
    currentUser = {
      pubkey: userPubkey,
      npub,
      profile,
      bunker: true
    };

    userFollowing = new Set(follows);
    bunkerConnection = { signer, pubkey: userPubkey };

    // ✅ DEBUG: prove currentUser is set
    console.log('✅ completeBunkerLogin set currentUser:', currentUser);

    // ✅ update UI IMMEDIATELY (this is the important part)
    updateUserUI();

    // ✅ DEBUG: prove input changed
    console.log('✅ after updateUserUI npub-input value:', input?.value);

    statusEl.textContent = 'Login successful!';

    setTimeout(() => {
      document.getElementById('bunker-login-modal').classList.remove('visible');
      // (optional) update again after modal closes
      updateUserUI();
    }, 500);

  } catch (err) {
    console.error('Complete login error:', err);
    const statusEl = document.getElementById('bunker-status');
    statusEl.className = 'bunker-status error';
    statusEl.textContent = 'Login failed: ' + err.message;
  }
}

// Fetch profile
async function fetchProfile(pubkeyHex) {
    if (profileCache.has(pubkeyHex)) return profileCache.get(pubkeyHex);

    try {
        const events = await pool.querySync(RELAYS, {
            kinds: [0],
            authors: [pubkeyHex],
            limit: 1
        });

        if (events.length === 0) {
            return {
                pubkey: pubkeyHex,
                name: 'Anonymous',
                about: '',
                picture: null
            };
        }

        const profile = JSON.parse(events[0].content);
        profile.pubkey = pubkeyHex;
        profileCache.set(pubkeyHex, profile);
        return profile;
    } catch (err) {
        console.error('Profile fetch error:', err);
        return {
            pubkey: pubkeyHex,
            name: 'Anonymous',
            about: '',
            picture: null
        };
    }
}

            // Fetch recent notes for engagement analysis
            async function fetchRecentNotes(pubkeyHex, limit = 50) {  // Changed from 10 to 50
                if (noteCache.has(pubkeyHex)) return noteCache.get(pubkeyHex);

                try {
                    const events = await pool.querySync(RELAYS, {
                        kinds: [1],
                        authors: [pubkeyHex],
                        limit: limit
                    });

                    noteCache.set(pubkeyHex, events);
                    return events;
                } catch (err) {
                    return [];
                }
            }

            // Fetch follows
            async function fetchFollows(pubkeyHex) {
                try {
                    const events = await pool.querySync(RELAYS, {
                        kinds: [3],
                        authors: [pubkeyHex],
                        limit: 1
                    });

                    if (events.length === 0) return [];

                    return events[0].tags
                        .filter(tag => tag[0] === 'p')
                        .map(tag => tag[1]);
                } catch (err) {
                    return [];
                }
            }

            // Batch fetch helper to avoid rate limiting
async function batchFetch(items, fetchFn, batchSize = 10, delayMs = 100) {
    const results = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(items.length / batchSize)}`);
        
        try {
            const batchResults = await Promise.all(
                batch.map(item => fetchFn(item).catch(err => {
                    console.error('Batch item error:', err);
                    return null; // Return null instead of failing entire batch
                }))
            );
            
            results.push(...batchResults);
        } catch (err) {
            console.error('Batch error:', err);
            // Push nulls for failed batch
            results.push(...Array(batch.length).fill(null));
        }
        
        // Small delay between batches to avoid rate limits
        if (i + batchSize < items.length) {
            await new Promise(resolve => setTimeout(resolve, delayMs));
        }
    }
    
    return results;
}

            // Search for users who post about specific hashtags
async function searchUsersByHashtags(hashtags, limit = 50) {
    console.log('Searching posts for hashtags:', hashtags);
    
    const userCandidates = new Map(); // pubkey -> post count
    const hashtagArray = Array.from(hashtags);
    
    try {
        // Search for notes with these hashtags
        for (const tag of hashtagArray) {
            console.log('Searching for #' + tag);
            
            const events = await pool.querySync(RELAYS, {
                kinds: [1], // Text notes
                '#t': [tag.toLowerCase()], // Hashtag search
                limit: 100 // Get 100 posts per tag
            });
            
            console.log(`Found ${events.length} posts for #${tag}`);
            
            // Count posts per user
            events.forEach(event => {
                const count = userCandidates.get(event.pubkey) || 0;
                userCandidates.set(event.pubkey, count + 1);
            });

            // ADD DELAY between hashtag searches to avoid rate limits
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Sort by number of matching posts and return top users
        const sortedUsers = Array.from(userCandidates.entries())
            .sort((a, b) => b[1] - a[1]) // Sort by post count
            .slice(0, limit)
            .map(([pubkey]) => pubkey);
        
        console.log(`Found ${sortedUsers.length} unique users posting about these topics`);
        return sortedUsers;
        
    } catch (err) {
        console.error('Hashtag search error:', err);
        return [];
    }
}

// Get hashtags from user's recent posts (not just bio)
async function getUserPostHashtags(pubkey, limit = 20) {
    try {
        const events = await pool.querySync(RELAYS, {
            kinds: [1],
            authors: [pubkey],
            limit: limit
        });
        
        const hashtags = new Set();
        events.forEach(event => {
            const tags = event.tags.filter(t => t[0] === 't');
            tags.forEach(t => hashtags.add(t[1].toLowerCase()));
        });
        
        return Array.from(hashtags);
    } catch (err) {
        return [];
    }
}

            // Calculate advanced match score based on multiple metrics
            // SCORING BREAKDOWN:
            // 
            // Social Score (0-100):
            //   - Each mutual follow = +10 points
            //   - If they follow you = +20 bonus
            // 
            // Interest Score (0-100):
            //   - Each shared hashtag = +25 points
            //   - Compares hashtags in your bio vs theirs
            // 
            // Engagement Score (0-100):
            //   - Based on recent posting activity
            //   - More posts = higher score
            // 
            // Niche Score (0-100):
            //   - Measures topic consistency
            //   - High = focused on specific topics
            //   - Low = diverse interests
            // 
            // FINAL SCORE depends on selected mode:
            //   Social Graph: 70% social, 20% interests, 10% engagement
            //   Shared Interests: 70% interests, 20% social, 10% niche
            //   High Engagement: 70% engagement, 20% social, 10% interests
            //   Niche Communities: 70% niche, 20% interests, 10% social
            //   Hashtag Discovery: 100% hashtag match based on selected tags
            function calculateMatchScore(userProfile, candidateProfile, userFollows, candidateFollows, candidateNotes, searchTags = null) {
                let scores = {
                    social: 0,      // Friend graph overlap
                    interests: 0,   // Shared hashtags/topics
                    engagement: 0,  // Activity level
                    niche: 0,       // Specific topic depth
                    hashtag: 0      // Hashtag search match
                };

                // Social graph analysis
                if (userFollows && candidateFollows) {
                    const mutualFollows = candidateFollows.filter(f => userFollows.includes(f)).length;
                    const followsYou = candidateFollows.includes(userProfile.pubkey);
                    scores.social = Math.min(100, (mutualFollows * 10) + (followsYou ? 20 : 0));
                }

                // Interest matching (hashtags from both bio AND posts)
const userBioHashtags = (userProfile.about || '').match(/#\w+/gi) || [];
const candidateBioHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];

// Extract hashtags from actual posts (much more accurate!)
const userPostHashtags = new Set();
if (candidateNotes) {
    candidateNotes.forEach(note => {
        const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
        tags.forEach(tag => userPostHashtags.add(tag));
    });
}

// Combine bio and post hashtags for candidate
const allCandidateHashtags = [
    ...candidateBioHashtags.map(h => h.toLowerCase().replace('#', '')),
    ...Array.from(userPostHashtags)
];

// Check overlap with user's bio hashtags
const sharedHashtags = userBioHashtags.filter(h => 
    allCandidateHashtags.some(ch => ch === h.toLowerCase().replace('#', ''))
).length;

scores.interests = Math.min(100, sharedHashtags * 25);

                // Engagement analysis
                if (candidateNotes && candidateNotes.length > 0) {
                    const avgNotesPerDay = candidateNotes.length / 7; // Assuming last week
                    scores.engagement = Math.min(100, avgNotesPerDay * 15);
                }

                // Niche community detection (RARITY-BASED - finds uncommon topics)
const candidateBioTags = (candidateProfile.about || '').match(/#\w+/gi) || [];
const candidatePostTags = new Set();
if (candidateNotes) {
    candidateNotes.forEach(note => {
        const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
        tags.forEach(tag => candidatePostTags.add(tag));
    });
}

// Combine all their hashtags
const allTopics = [
    ...candidateBioTags.map(h => h.toLowerCase().replace('#', '')),
    ...Array.from(candidatePostTags)
];

// Score based on RARITY (uncommon topics = high score)
if (allTopics.length > 0 && window.topicPopularity) {
    const rarityScores = allTopics.map(topic => {
        const popularity = window.topicPopularity.get(topic) || 1;
        const totalProfiles = window.topicPopularity.size;
        // Rarity: topics that appear in <10% of profiles get bonus
        const rarityPercent = (popularity / totalProfiles) * 100;
        return rarityPercent < 10 ? (100 - rarityPercent * 5) : 0;
    });
    
    const avgRarity = rarityScores.reduce((a, b) => a + b, 0) / rarityScores.length;
    scores.niche = Math.min(100, Math.max(0, avgRarity));
} else {
    scores.niche = 0;
}

                // Hashtag search matching (for hashtag discovery mode)
if (searchTags && searchTags.size > 0) {
    // Get hashtags from BOTH bio and posts
    const bioHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];
    const postHashtags = new Set();
    if (candidateNotes) {
        candidateNotes.forEach(note => {
            const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
            tags.forEach(tag => postHashtags.add(tag));
        });
    }
    
    // Combine all hashtags
    const allCandidateHashtags = [
        ...bioHashtags.map(h => h.toLowerCase().replace('#', '')),
        ...Array.from(postHashtags)
    ];
    
    // DEBUG: Show what we're finding
    if (candidateProfile.pubkey === userProfile.pubkey) {
        console.log('🔍 YOUR HASHTAG DEBUG:');
        console.log('  Bio hashtags:', bioHashtags);
        console.log('  Post hashtags:', Array.from(postHashtags));
        console.log('  All combined:', allCandidateHashtags);
        console.log('  Searching for:', Array.from(searchTags));
        console.log('  Your notes count:', candidateNotes?.length);
    }
    
    const searchArray = Array.from(searchTags);
    const matches = searchArray.filter(tag => 
        allCandidateHashtags.some(ct => ct.includes(tag))
    );
    
    if (candidateProfile.pubkey === userProfile.pubkey) {
        console.log('  Matches found:', matches);
        console.log('  Final hashtag score:', matches.length > 0 ? ((matches.length / searchArray.length) * 100) : 0);
    }
    
    if (matchMode === 'all') {
        // ALL tags must be present
        scores.hashtag = matches.length === searchArray.length ? 100 : 0;
    } else {
        // ANY tag match
        scores.hashtag = Math.min(100, (matches.length / searchArray.length) * 100);
    }
}

                // Weight scores based on discovery mode
                let finalScore = 0;
                switch(discoveryMode) {
                    case 'social':
                        finalScore = scores.social * 0.7 + scores.interests * 0.2 + scores.engagement * 0.1;
                        break;
                    case 'interests':
                        finalScore = scores.interests * 0.7 + scores.social * 0.2 + scores.niche * 0.1;
                        break;
                    case 'niche':
                        finalScore = scores.niche * 0.7 + scores.interests * 0.2 + scores.social * 0.1;
                        break;
                    case 'hashtags':
                        finalScore = scores.hashtag * 0.8 + scores.engagement * 0.15 + scores.social * 0.05;
                        break;
                }

                return {
                    total: Math.min(99, Math.max(60, Math.round(finalScore))),
                    breakdown: scores
                };
            }

            // Get recommendations based on discovery mode
            // HOW IT WORKS:
            // 1. Fetches your follow list (people you follow)
            // 2. Samples 10 of your follows
            // 3. Gets their follow lists (second-degree connections)
            // 4. Filters out people you already follow and yourself
            // 5. Returns candidates for scoring
            async function getRecommendations(userPubkey, limit) {
    const userFollows = await fetchFollows(userPubkey);
    
    console.log('User follows:', userFollows.length);
    
    // If user has no follows, search for popular accounts instead
    if (userFollows.length === 0) {
        console.log('No follows found, searching popular users...');
        
        try {
            // Get recent popular posts to find active users
            const recentEvents = await pool.querySync(RELAYS, {
                kinds: [1],
                limit: 200
            });
            
            // Count posts per user
            const userCounts = new Map();
            recentEvents.forEach(event => {
                const count = userCounts.get(event.pubkey) || 0;
                userCounts.set(event.pubkey, count + 1);
            });
            
            // Return top active users
            const topUsers = Array.from(userCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit * 3)
                .map(([pubkey]) => pubkey);
            
            console.log('Found', topUsers.length, 'popular users');
            return topUsers;
        } catch (err) {
            console.error('Error finding popular users:', err);
            // Fallback to some known good accounts
            return [
                '82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2',
                '460c25e682fda7832b52d1f22d3d22b3176d972f60dcdc3212ed8c92ef85065c',
                '3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d',
                'npub1sn0wdenkukak0d9dfczzeacvhkrgz92ak56egt7vdgzn8pv2wfqqhrjdv9', // @jack
                'npub180cvv07tjdrrgpa0j7j7tmnyl2yr6yr7l8j4s3evf6u64th6gkwsyjh6w6', // fiatjaf
            ];
        }
    }

    const candidates = new Set();
    const sampleSize = Math.min(20, userFollows.length); // Increased from 15 to 20
    
    console.log('Sampling', sampleSize, 'of your', userFollows.length, 'follows');
    
    const shuffledFollows = [...userFollows].sort(() => Math.random() - 0.5);
    
    const followPromises = [];
    for (let i = 0; i < sampleSize; i++) {
        followPromises.push(fetchFollows(shuffledFollows[i]));
    }

    const results = await Promise.all(followPromises);
    
    results.forEach(theirFollows => {
        theirFollows.forEach(pubkey => {
            if (pubkey !== userPubkey && !userFollows.includes(pubkey)) {
                candidates.add(pubkey);
            }
        });
    });

    const candidateArray = Array.from(candidates).sort(() => Math.random() - 0.5);
    console.log('Generated', candidateArray.length, 'total candidates');
    
    return candidateArray.slice(0, limit * 5); // Increased multiplier from 3 to 5
}


            async function followUser(pubkey) {
    if (!currentUser) {
        alert('Please login first');
        return false;
    }

                // Check if using bunker or extension
                const useBunker = currentUser.bunker && bunkerConnection;
                const useExtension = !useBunker && await checkExtension();

                if (!useBunker && !useExtension) {
                    alert('No signing method available');
                    return false;
                }

    try {
        const currentFollows = Array.from(userFollowing);
        if (!currentFollows.includes(pubkey)) {
            currentFollows.push(pubkey);
        }

        const event = {
            kind: 3,
            created_at: Math.floor(Date.now() / 1000),
            tags: currentFollows.map(pk => ['p', pk]),
            content: ''
        };

                    let signedEvent;
                    
                    if (useBunker) {
                        // Sign with bunker
                        signedEvent = await signEventWithBunker(event);
                        if (!signedEvent) {
                            throw new Error('Bunker signing failed');
                        }
                    } else {
                        // Sign with extension
                        signedEvent = await window.nostr.signEvent(event);
                    }

                    await Promise.all(RELAYS.map(relay => pool.publish([relay], signedEvent)));
                    userFollowing.add(pubkey);
                    return true;
                } catch (err) {
                    console.error('Follow error:', err);
                    return false;
                }
            }

            // Sign event using BunkerSigner
async function signEventWithBunker(event) {
    if (!bunkerConnection || !bunkerConnection.signer) {
        throw new Error('Bunker not connected');
    }
    
    try {
        // Use official signer's signEvent method
        const signedEvent = await bunkerConnection.signer.signEvent(event);
        return signedEvent;
    } catch (err) {
        console.error('Bunker signing error:', err);
        throw err;
    }
}

            // Create profile card (reusable function)
            function createProfileCard(fren) {
                const card = document.createElement('div');
                card.className = 'fren-card';
                
                // Add class if already following
                if (fren.isFollowing) {
                    card.classList.add('already-following');
                }
                
                const hashtags = (fren.about.match(/#\w+/g) || []).slice(0, 3).map(t => t.substring(1));
                
                // Determine which metrics to highlight
                let metricsHTML = '<div class="metrics-container">';
                
                // Add cross-reference badge if applicable
                if (fren.crossRefCategory) {
                    if (fren.crossRefCategory === 'mutual') {
                        metricsHTML += `<span class="metric-badge high">Both Follow</span>`;
                    } else if (fren.crossRefCategory === 'you-only') {
                        metricsHTML += `<span class="metric-badge medium">You Follow</span>`;
                    } else if (fren.crossRefCategory === 'them-only') {
                        metricsHTML += `<span class="metric-badge medium">They Follow</span>`;
                    }
                }
                
                if (fren.scores.breakdown.social > 40) {
                    metricsHTML += `<span class="metric-badge high">${fren.mutual || 0} Mutual</span>`;
                }
                if (fren.scores.breakdown.interests > 40) {
                    metricsHTML += `<span class="metric-badge medium">${hashtags.length} Tags</span>`;
                }
                if (fren.scores.breakdown.engagement > 40) {
                    metricsHTML += `<span class="metric-badge high">Active</span>`;
                }
                metricsHTML += '</div>';
                
                card.innerHTML = `
                    <div class="fren-header">
                        <img src="${fren.picture || `https://robohash.org/${fren.pubkey}?set=set5`}" 
                             class="fren-avatar" 
                             onerror="this.src='https://robohash.org/${fren.pubkey}?set=set5'">
                        <div class="fren-info">
                            <div class="fren-name">${fren.name}</div>
                            <div class="fren-npub" onclick="copyNpub('${fren.npub}')">${fren.npub.substring(0,20)}...</div>
                        </div>
                        <div class="match-score">${fren.scores.total}%</div>
                    </div>
                    <p class="fren-bio">${fren.about.substring(0, 150)}${fren.about.length > 150 ? '...' : ''}</p>
                    ${metricsHTML}
                    ${hashtags.length > 0 ? `
                        <div class="tags-container">
                            ${hashtags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="fren-actions">
                        <button class="btn-follow ${fren.isFollowing ? 'following' : ''}" 
                                data-pubkey="${fren.pubkey}"
                                ${!currentUser ? 'disabled' : ''}>
                            ${fren.isFollowing ? 'Following' : 'Follow'}
                        </button>
                        <a href="https://njump.me/${fren.npub}" target="_blank" class="btn-view-profile">View</a>
                    </div>
                `;

                const followBtn = card.querySelector('.btn-follow');
                followBtn.addEventListener('click', async () => {
                    if (fren.isFollowing) return;
                    followBtn.disabled = true;
                    followBtn.textContent = 'Following...';
                    const success = await followUser(fren.pubkey);
                    if (success) {
                        followBtn.textContent = 'Following';
                        followBtn.classList.add('following');
                        fren.isFollowing = true;
                    } else {
                        followBtn.disabled = false;
                        followBtn.textContent = 'Follow';
                    }
                });

                return card;
            }

            // Render results
            function renderResults(profiles) {
                const resultsGrid = document.getElementById('results-grid');
                resultsGrid.innerHTML = '';

                profiles.forEach(fren => {
                    const card = createProfileCard(fren);
                    resultsGrid.appendChild(card);
                });
            }

            // Main search
            document.getElementById('find-btn').addEventListener('click', async () => {
    const findBtn = document.getElementById('find-btn');
    const resultsSection = document.getElementById('results-section');
    const emptyState = document.getElementById('empty-state');
    const resultsGrid = document.getElementById('results-grid');

    // Validate hashtag mode
    if (discoveryMode === 'hashtags') {
        if (selectedHashtags.size === 0) {
            alert('Please select at least one hashtag to search');
            return;
        }
        console.log('Hashtag discovery mode:', Array.from(selectedHashtags), 'Match mode:', matchMode);
    }

    // ✅ SOURCE OF TRUTH: logged in user first, otherwise manual input
    let userPubkey;

    if (currentUser && currentUser.pubkey) {
        userPubkey = currentUser.pubkey; // extension OR bunker
    } else {
        const npubInput = document.getElementById('npub-input').value.trim();

        if (!npubInput) {
            alert('Please enter your npub or login');
            return;
        }

        if (!npubInput.startsWith('npub1')) {
            alert('Invalid npub format');
            return;
        }

        userPubkey = nip19.decode(npubInput).data;
    }

    // Prevent multiple simultaneous searches
    if (findBtn.disabled) return;

    findBtn.disabled = true;
    findBtn.textContent = 'Discovering...';
    emptyState.style.display = 'none';
    resultsSection.style.display = 'block';
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';

    try {
        const userProfile = await fetchProfile(userPubkey);
        const userFollows = await fetchFollows(userPubkey);

        // ✅ if not logged in, still use follows to mark "already following"
        if (!currentUser) {
            userFollowing = new Set(userFollows);
            console.log('Loaded follows for manual npub:', userFollowing.size);
        }
                    
                    if (!currentUser) {
        userFollowing = new Set(userFollows);
        console.log('Loaded follows for manual npub:', userFollowing.size);
    }

                    let candidatePubkeys;

// For hashtag discovery mode, ALWAYS do global search (ignore cross-ref)
if (discoveryMode === 'hashtags' && selectedHashtags.size > 0) {
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Searching posts for matching hashtags...</p>';
    candidatePubkeys = await searchUsersByHashtags(selectedHashtags, parseInt(document.getElementById('result-count').value) * 3);

 // DEBUG: Check if you're in the results
    console.log('=== HASHTAG SEARCH DEBUG ===');
    console.log('Found candidates:', candidatePubkeys.length);
    console.log('Your pubkey:', userPubkey);
    console.log('Are you in results?', candidatePubkeys.includes(userPubkey));
    console.log('First 5 candidates:', candidatePubkeys.slice(0, 5));
}

// Use cross-reference data if enabled (for other modes)
else if (crossRefEnabled && crossRefData) {
    const allCandidates = [
        ...crossRefData.youOnly,
        ...crossRefData.themOnly,
        ...crossRefData.mutual
    ];
    
    candidatePubkeys = Array.from(new Set(allCandidates))
        .slice(0, parseInt(document.getElementById('result-count').value) * 2);
    
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Comparing networks...</p>';
}
// Default: social graph recommendations
else {
    candidatePubkeys = await getRecommendations(userPubkey, parseInt(document.getElementById('result-count').value));
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';
}
                    
                    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Calculating match scores...</p>';

                    // Fetch data in parallel batches to avoid rate limiting (MUCH FASTER!)
console.log('Fetching', candidatePubkeys.length, 'profiles, follows, and notes...');

const [allProfiles, allFollows, allNotes] = await Promise.all([
    batchFetch(candidatePubkeys, fetchProfile, 5, 300),  // Reduced from 10 to 5, increased delay
    batchFetch(candidatePubkeys, fetchFollows, 5, 300),
    batchFetch(candidatePubkeys, (pk) => fetchRecentNotes(pk, 50), 5, 300)
]);

// Build topic popularity map for niche detection
const topicPopularity = new Map();
allNotes.forEach((notes, idx) => {
    if (!notes) return;
    const profile = allProfiles[idx];
    if (!profile) return;
    
    // Get hashtags from bio
    const bioHashtags = (profile.about || '').match(/#\w+/gi) || [];
    bioHashtags.forEach(tag => {
        const normalized = tag.toLowerCase().replace('#', '');
        topicPopularity.set(normalized, (topicPopularity.get(normalized) || 0) + 1);
    });
    
    // Get hashtags from posts
    notes.forEach(note => {
        const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
        tags.forEach(tag => {
            topicPopularity.set(tag, (topicPopularity.get(tag) || 0) + 1);
        });
    });
});

console.log('Topic popularity map built:', topicPopularity.size, 'unique topics');

// Make available to scoring function
window.topicPopularity = topicPopularity;

// DEBUG: Check what we got
console.log('Profiles loaded:', allProfiles.filter(p => p !== null).length, '/', allProfiles.length);
console.log('Sample profile:', allProfiles[0]);

console.log('All data fetched!');

                    const profiles = allProfiles
    .map((profile, idx) => {
        if (!profile.pubkey) return null;
        
        const spamScore = detectSpam(profile, allNotes[idx]);
        const isNSFW = detectNSFW(profile);
        
        const scores = calculateMatchScore(
            userProfile,
            profile,
            userFollows,
            allFollows[idx],
            allNotes[idx],
            discoveryMode === 'hashtags' ? selectedHashtags : null
        );

        const mutual = allFollows[idx].filter(f => userFollows.includes(f)).length;

        let crossRefCategory = null;
        if (crossRefEnabled && crossRefData) {
            if (crossRefData.mutual.includes(profile.pubkey)) {
                crossRefCategory = 'mutual';
            } else if (crossRefData.youOnly.includes(profile.pubkey)) {
                crossRefCategory = 'you-only';
            } else if (crossRefData.themOnly.includes(profile.pubkey)) {
                crossRefCategory = 'them-only';
            }
        }

        return {
    ...profile,
    npub: nip19.npubEncode(profile.pubkey),
    scores: scores,
    mutual: mutual,
    isFollowing: userFollowing.has(profile.pubkey),
    spamScore: spamScore,
    isNSFW: isNSFW,
    crossRefCategory: crossRefCategory,
    notes: allNotes[idx],
    follows: allFollows[idx]
};
    })

    .filter(p => {
    if (!p) {
        console.log('❌ Filtered: null profile');
        return false;
    }
    
    // DEBUG: Track YOUR profile specifically
    const isYou = p.pubkey === userPubkey;
    if (isYou) console.log('🔍 Checking YOUR profile:', p.name);
    
    if (discoveryMode === 'hashtags' && p.scores.breakdown.hashtag === 0) {
        if (isYou) console.log('❌ YOU filtered: hashtag score is 0');
        return false;
    }
    
    const hideSpam = document.getElementById('hide-spam').checked;
    if (hideSpam && p.spamScore > 60) {
        if (isYou) console.log('❌ YOU filtered: spam score', p.spamScore);
        console.log('Filtering spam:', p.name, 'Score:', p.spamScore);
        return false;
    }
    
    const hideNSFW = document.getElementById('hide-nsfw').checked;
    if (hideNSFW && p.isNSFW) {
        if (isYou) console.log('❌ YOU filtered: NSFW');
        console.log('Filtering NSFW:', p.name);
        return false;
    }
    
    const recentActivityOnly = document.getElementById('recent-activity-only').checked;
    if (recentActivityOnly) {
        const thirtyDaysAgo = Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);
        const hasRecentNote = p.notes?.some(note => note.created_at > thirtyDaysAgo);
        
        if (!hasRecentNote) {
            if (isYou) console.log('❌ YOU filtered: no recent activity');
            console.log('Filtering inactive:', p.name, '- no posts in last 30 days');
            return false;
        }
    }
    
    const minFollowers = parseInt(document.getElementById('min-followers').value);
    if (minFollowers > 0) {
        const followCount = p.follows?.length || 0;
        if (followCount < minFollowers) {
            if (isYou) console.log('❌ YOU filtered: network too small', followCount);
            console.log('Filtering small network:', p.name, 'Follows:', followCount);
            return false;
        }
    }
    
    const activityLevel = document.getElementById('activity-level').value;
    if (activityLevel !== 'any' && p.notes) {
        const tenDaysAgo = Math.floor(Date.now() / 1000) - (10 * 24 * 60 * 60);
        const thirtyDaysAgo = Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);
        
        const recentPosts = p.notes.filter(note => note.created_at > tenDaysAgo).length;
        const monthPosts = p.notes.filter(note => note.created_at > thirtyDaysAgo).length;
        
        if (activityLevel === 'high' && recentPosts < 5) {
            if (isYou) console.log('❌ YOU filtered: activity level too low', recentPosts);
            console.log('Filtering low activity:', p.name, 'Recent posts:', recentPosts);
            return false;
        }
        if (activityLevel === 'medium' && recentPosts < 2) {
            if (isYou) console.log('❌ YOU filtered: activity level too low', recentPosts);
            console.log('Filtering low activity:', p.name, 'Recent posts:', recentPosts);
            return false;
        }
        if (activityLevel === 'low' && monthPosts < 1) {
            if (isYou) console.log('❌ YOU filtered: no monthly activity', monthPosts);
            console.log('Filtering inactive:', p.name, 'Month posts:', monthPosts);
            return false;
        }
    }
    
    if (isYou) console.log('✅ YOU passed all filters!');
    return true;
})


    .sort((a, b) => b.scores.total - a.scores.total)
    .slice(0, parseInt(document.getElementById('result-count').value));

                    // Separate into new discoveries and already following
                    const hideFollowing = document.getElementById('hide-following').checked;
                    
                    let newProfiles, followingProfiles;
                    
                    if (hideFollowing) {
                        // When hiding, separate them
                        newProfiles = profiles.filter(p => !p.isFollowing);
                        followingProfiles = profiles.filter(p => p.isFollowing);
                    } else {
                        // When showing, put all in main grid
                        newProfiles = profiles;
                        followingProfiles = [];
                    }

                    // Display profiles
document.getElementById('results-count').textContent = `${newProfiles.length} matches`;

// Show message if no new profiles found
if (newProfiles.length === 0 && followingProfiles.length > 0) {
    resultsGrid.innerHTML = `
        <div style="text-align:center;padding:3rem;">
            <h3 style="margin-bottom:1rem;">No New Discoveries</h3>
            <p style="color:var(--text-secondary);">All ${followingProfiles.length} matches are people you already follow.</p>
            <p style="color:var(--text-secondary);margin-top:0.5rem;">Try unchecking "Hide Already Following" or searching with different criteria.</p>
        </div>
    `;
} else {
    renderResults(newProfiles);
}

// Display already following section if there are any AND hiding is enabled
const followingSection = document.getElementById('following-section');
const followingGrid = document.getElementById('following-grid');

if (followingProfiles.length > 0 && hideFollowing && newProfiles.length > 0) {
    // Only show section if there are ALSO new profiles to display
    followingSection.style.display = 'block';
    document.getElementById('following-count').textContent = followingProfiles.length;
    
    // Render following profiles in separate grid
    followingGrid.innerHTML = '';
    followingProfiles.forEach(fren => {
        const card = createProfileCard(fren);
        followingGrid.appendChild(card);
    });
} else {
    followingSection.style.display = 'none';
    followingGrid.innerHTML = '';  // ✅ CLEAR the grid when hiding!
}

                } catch (err) {
                    console.error('Error:', err);
                    resultsGrid.innerHTML = `<p style="text-align:center;padding:2rem;color:var(--accent-primary)">Error: ${err.message}</p>`;
                } finally {
                    findBtn.disabled = false;
                    findBtn.textContent = 'Discover Frens';
                }
            });

            document.getElementById('npub-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('find-btn').click();
            });

            window.copyNpub = (npub) => {
                navigator.clipboard.writeText(npub).then(() => console.log('Copied:', npub));
            };

            document.getElementById('following-header').addEventListener('click', function() {
                const content = document.getElementById('following-content');
                const icon = document.getElementById('following-icon');
                
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    icon.textContent = '▼';
                } else {
                    content.style.display = 'none';
                    icon.textContent = '▶';
                }
            });

            // Close bunker modal
            document.getElementById('close-bunker').addEventListener('click', function() {
                document.getElementById('bunker-login-modal').classList.remove('visible');
                if (bunkerAbortController) {
                    bunkerAbortController.abort();
                }
            });

            document.getElementById('bunker-login-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.remove('visible');
                    if (bunkerAbortController) {
                        bunkerAbortController.abort();
                    }
                }
            });

             updateUserUI();
            
    // ============ MAIN APPLICATION END ============
        }); // End: window.addEventListener('load', async function() {
    </script>
</body>
</html>