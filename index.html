<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://unpkg.com https://cdn.jsdelivr.net https://esm.sh;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://fonts.gstatic.com data:;
    img-src 'self' https: data: blob:;
    media-src 'self' https: data: blob:;
    connect-src 'self' https: wss:;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    upgrade-insecure-requests;
">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <title>Fren Finder - Advanced Nostr Discovery</title>
    <link rel="icon" href="./favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #faf8f5;
            --bg-secondary: #f0ede7;
            --bg-tertiary: #e8e3da;
            --text-primary: #1a1512;
            --text-secondary: #5a524a;
            --text-tertiary: #8a7f72;
            --accent-primary: #c84e3a;
            --accent-secondary: #2d5f4f;
            --accent-success: #2d7a4f;
            --accent-info: #3a6ea5;
            --border-color: #d4cec2;
            --shadow-color: rgba(26, 21, 18, 0.08);
            --transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1512;
            --bg-secondary: #2a2319;
            --bg-tertiary: #3a3229;
            --text-primary: #faf8f5;
            --text-secondary: #c4beb4;
            --text-tertiary: #8a7f72;
            --accent-primary: #e8745e;
            --accent-secondary: #4a9276;
            --accent-success: #4a9a70;
            --accent-info: #5a8ec5;
            --border-color: #3a3229;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            transition: var(--transition);
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        header {
            padding: 3rem 0 2rem;
            border-bottom: 1px solid var(--border-color);
            animation: fadeInDown 0.6s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .logo-section h1 {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }

        .user-info-combined {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 1.5rem 0.5rem 0.5rem;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.7));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(200, 78, 58, 0.2);
            border-radius: 3rem;
            transition: var(--transition);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08),
                        inset 0 1px 0 rgba(255, 255, 255, 0.9);
            cursor: pointer;
        }

        [data-theme="dark"] .user-info-combined {
            background: linear-gradient(135deg, rgba(42, 35, 25, 0.9), rgba(58, 50, 41, 0.8));
            border: 1px solid rgba(232, 116, 94, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .user-info-combined:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 24px rgba(200, 78, 58, 0.12),
                        inset 0 1px 0 rgba(255, 255, 255, 1);
            border-color: rgba(200, 78, 58, 0.4);
        }

        [data-theme="dark"] .user-info-combined:hover {
            box-shadow: 0 6px 24px rgba(232, 116, 94, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        .user-info-combined:hover .user-action {
            color: var(--accent-primary);
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            border: 2.5px solid var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(200, 78, 58, 0.1),
                        0 4px 12px rgba(0, 0, 0, 0.15);
            transition: var(--transition);
        }

        .user-info-combined:hover .user-avatar {
            transform: scale(1.03);
            box-shadow: 0 0 0 3px rgba(200, 78, 58, 0.15),
                        0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .user-details {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
        }

        .user-name {
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: 0.01em;
        }

        .user-action {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-tertiary);
            transition: var(--transition);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: var(--transition);
            font-weight: 600;
            border: none;
        }

        .btn-login {
            background: var(--accent-primary);
            color: var(--bg-primary);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .theme-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .theme-toggle:hover {
            background: var(--bg-tertiary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        main {
            padding: 3rem 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .search-section {
            margin-bottom: 3rem;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }

        input[type="text"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .discovery-mode {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .mode-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
        }

        .mode-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .mode-card.active {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            box-shadow: 0 4px 16px var(--shadow-color);
            /* FIX: Add stronger visual indicator for active mode */
            border-width: 3px;
        }

        .mode-card.active .mode-title {
            color: var(--accent-primary);
        }

        .mode-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .mode-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        select {
            padding: 0.875rem 1.25rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition);
        }

        select:focus {
            outline: none;
            border-color: var(--accent-secondary);
        }

        .btn-primary {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 1rem;
        }

        .results-header h2 {
            font-size: 2rem;
            font-weight: 600;
        }

        .results-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .results-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .sort-dropdown {
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .fren-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    padding: 1.75rem;
    transition: var(--transition);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

        .fren-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-primary);
            transform: scaleY(0);
            transition: var(--transition);
        }

        .fren-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .fren-card:hover::before {
            transform: scaleY(1);
        }

        .fren-card.already-following {
            opacity: 0.6;
            background: var(--bg-tertiary);
        }

        .fren-card.already-following:hover {
            opacity: 0.8;
        }

        .fren-header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 1rem;
    width: 100%;
    flex-wrap: nowrap;
}

        .fren-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
            flex-shrink: 0;
        }

        .fren-info {
    flex: 1;
    min-width: 0;
    overflow: hidden;
}

.match-score {
    flex-shrink: 0;
}

        .fren-name {
    /* FIX: Allow wrapping for long names with special characters */
    word-break: break-word;
    overflow-wrap: break-word;
    max-width: 100%;
    /* Allow up to 2 lines before truncating */
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

        .fren-npub {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: var(--transition);
            padding: 0.25rem;
            border-radius: 0.25rem;
        }

        .fren-npub:hover {
            color: var(--accent-primary);
        }

        .match-score {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            padding: 0.4rem 0.8rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            flex-shrink: 0;
            white-space: nowrap;
        }

        .fren-bio {
    max-height: 80px;        /* whatever height you want */
    overflow-y: scroll;
    padding-right: 6px;      /* prevents text cutoff */
    scrollbar-width: none;   /* Firefox */
}

.fren-bio::-webkit-scrollbar {
    display: none;           /* Chrome, Safari */
}

        .metrics-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-top: 1rem;       /* ← THIS is the key */
    margin-bottom: 1.25rem;
}

        .metric-badge {
            background: var(--bg-tertiary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .metric-badge.high {
            background: var(--accent-success);
            color: var(--bg-primary);
            border-color: var(--accent-success);
        }

        .metric-badge.medium {
            background: var(--accent-info);
            color: var(--bg-primary);
            border-color: var(--accent-info);
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .tag {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
        }

        .fren-actions {
    display: flex;
    gap: 0.75rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
    margin-top: auto;
}

        .btn-follow {
            flex: 1;
            padding: 0.75rem;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .btn-follow:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-follow:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-follow.following {
            background: var(--accent-success);
        }

        .btn-view-profile {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            color: var(--text-primary);
            display: inline-block;
        }

        .btn-view-profile:hover {
            background: var(--bg-secondary);
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        footer {
            border-top: 1px solid var(--border-color);
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
            color: var(--text-tertiary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .toggle-group {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-shrink: 0;
            min-width: 0;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            flex-shrink: 0;
        }

        .toggle-switch input[type="checkbox"] {
    display: none;
}

.toggle-switch input[type="checkbox"],
.xref-toggle input[type="checkbox"] {
    display: none;
}

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background-color: var(--bg-primary);
        }

        .toggle-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .already-following-section {
            margin-top: 3rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .following-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .following-header h3 {
            font-size: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .following-count {
            background: var(--accent-info);
            color: var(--bg-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .following-toggle-icon {
            font-size: 1.5rem;
            transition: var(--transition);
        }

        .following-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .following-content {
            display: none;
            padding-top: 1.5rem;
        }

        .following-content.visible {
            display: block;
        }

        .hashtag-search-container {
            display: none;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 0.75rem;
        }

        .hashtag-search-container.visible {
            display: block;
        }

        .hashtag-input-wrapper {
            position: relative;
            margin-bottom: 1rem;
        }

        .hashtag-input {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .hashtag-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .hashtag-input::placeholder {
            color: var(--text-tertiary);
        }

        .tag-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 10;
        }

        .tag-suggestions.visible {
            display: block;
        }

        .tag-suggestion-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }

        .tag-suggestion-item:hover {
            background: var(--bg-secondary);
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            min-height: 2.5rem;
        }

        .selected-tag {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2rem;
            line-height: 1;
        }

        .tag-remove:hover {
            transform: scale(1.2);
        }

        .match-mode-toggle {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .match-mode-btn {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            font-weight: 600;
        }

        .match-mode-btn.active {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .match-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .popular-tags {
            margin-top: 1rem;
        }

        .popular-tags-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .popular-tags-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .popular-tag {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .popular-tag:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .cross-reference-container {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .cross-ref-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cross-ref-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .cross-ref-toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
            flex-shrink: 0;
        }

        .cross-ref-toggle-switch input {
    display: none;
}

        .cross-ref-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .cross-ref-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider {
            background-color: var(--accent-info);
            border-color: var(--accent-info);
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider:before {
            transform: translateX(18px);
            background-color: var(--bg-primary);
        }

        .cross-ref-input {
            width: 100%;
            padding: 0.875rem 1.25rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            transition: var(--transition);
            display: none;
        }

        .cross-ref-input.visible {
            display: block;
        }

        .cross-ref-input:focus {
            outline: none;
            border-color: var(--accent-info);
        }

        .comparison-results {
            margin-top: 2rem;
            display: none;
        }

        .comparison-results.visible {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .comparison-category {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .comparison-category h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            color: var(--accent-info);
        }

        .comparison-count {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .comparison-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .login-dropdown {
            position: relative;
        }

        .login-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            box-shadow: 0 8px 24px var(--shadow-color);
            z-index: 100;
            min-width: 200px;
        }

        .login-menu.visible {
            display: block;
        }

        .login-option {
            padding: 0.875rem 1.25rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
        }

        .login-option:last-child {
            border-bottom: none;
        }

        .login-option:hover {
            background: var(--bg-secondary);
        }

        .nsec-warning-banner {
            display: none;
            background: rgba(200, 78, 58, 0.05);
            border: 1px solid rgba(200, 78, 58, 0.3);
            border-left: 3px solid var(--accent-primary);
            padding: 0.75rem 1rem;
            margin-bottom: 1.5rem;
            border-radius: 0.5rem;
            animation: fadeIn 0.3s ease-out;
        }

        .nsec-warning-banner.visible {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .nsec-warning-banner-icon {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-primary);
            flex-shrink: 0;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .nsec-warning-banner-content {
            flex: 1;
        }

        .nsec-warning-banner-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .nsec-warning-banner-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .nsec-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .nsec-modal.visible {
            display: flex;
        }

        .nsec-modal-content {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 8px 32px var(--shadow-color);
        }

        .nsec-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }

        .nsec-modal-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .nsec-close {
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            color: var(--text-secondary);
            transition: var(--transition);
            background: none;
            border: none;
            padding: 0;
        }

        .nsec-close:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .nsec-warning {
            background: rgba(200, 78, 58, 0.1);
            border: 2px solid var(--accent-primary);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .nsec-warning strong {
            color: var(--accent-primary);
            display: block;
            margin-bottom: 0.5rem;
        }

        .nsec-input-group {
            margin-bottom: 1.5rem;
        }

        .nsec-input-group label {
            display: block;
            margin-bottom: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
        }

        .nsec-input {
            width: 100%;
            padding: 1rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .nsec-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .nsec-actions {
            display: flex;
            gap: 1rem;
        }

        .nsec-btn {
            flex: 1;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            border: none;
        }

        .nsec-btn-primary {
            background: var(--accent-primary);
            color: var(--bg-primary);
        }

        .nsec-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.3);
        }

        .nsec-btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .nsec-btn-secondary:hover {
            background: var(--bg-secondary);
        }

        @media (max-width: 768px) {
            .logo-section h1 { font-size: 2.5rem; }
            .header-content { flex-direction: column; }
            .filter-row { grid-template-columns: 1fr; }
            .results-grid { grid-template-columns: 1fr; }
            .discovery-mode { grid-template-columns: 1fr; }
            .toggle-group { 
                flex-direction: column; 
                gap: 1rem;
                padding: 1rem;
            }
            .toggle-item {
                width: 100%;
                justify-content: flex-start;
            }
            
            /* Fix login dropdown on mobile */
            .login-menu {
                right: auto;
                left: 0;
            }
            
            /* Fix cross-reference container on mobile */
            .cross-reference-container {
                padding: 1rem;
            }
            
            .cross-ref-toggle {
                flex-wrap: nowrap;
            }
            
            .cross-ref-label {
                flex: 1;
                min-width: 0;
            }
        }
        
        @media (min-width: 769px) and (max-width: 1024px) {
            .discovery-mode {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="logo-section">
                    <h1>Fren Finder</h1>
                    <p class="subtitle">Advanced Nostr Discovery</p>
                </div>
                <div class="header-actions">
                    <div id="user-section"></div>
                    <button class="btn theme-toggle" id="theme-btn">Toggle Theme</button>
                </div>
            </div>
        </header>

        <main>
            <div class="container">
                <!-- Nsec Warning Banner -->
                <div class="nsec-warning-banner" id="nsec-warning-banner">
                    <div class="nsec-warning-banner-icon">Notice</div>
                    <div class="nsec-warning-banner-content">
                        <div class="nsec-warning-banner-title">Private Key Login Active</div>
                        <div class="nsec-warning-banner-text">
                            Logged in with nsec. Auto-logout after 15 min inactivity.
                        </div>
                    </div>
                </div>

                <section class="search-section">
                <div class="input-group">
                    <label for="npub-input">Your Nostr Public Key</label>
                    <input type="text" id="npub-input" placeholder="npub1... (or click Login)">
                </div>

                <div class="cross-reference-container">
                    <div class="cross-ref-toggle">
                        <label class="cross-ref-toggle-switch">
                            <input type="checkbox" id="enable-cross-ref">
                            <span class="cross-ref-toggle-slider"></span>
                        </label>
                        <div class="cross-ref-label">
                            Cross-Reference With Another Account
                        </div>
                    </div>
                    <input type="text" 
                           class="cross-ref-input" 
                           id="cross-ref-input" 
                           placeholder="Enter another npub to compare networks">
                    
                    <div class="comparison-results" id="comparison-results">
                        <div class="comparison-category">
                            <h4>You Follow</h4>
                            <div class="comparison-count" id="you-only-count">0</div>
                            <div class="comparison-desc">Accounts only you follow</div>
                        </div>
                        <div class="comparison-category">
                            <h4>Both Follow</h4>
                            <div class="comparison-count" id="mutual-count">0</div>
                            <div class="comparison-desc">Shared connections</div>
                        </div>
                        <div class="comparison-category">
                            <h4>They Follow</h4>
                            <div class="comparison-count" id="them-only-count">0</div>
                            <div class="comparison-desc">Accounts only they follow</div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Discovery Mode</label>
                    <div class="discovery-mode">
                        <div class="mode-card active" data-mode="social">
                            <div class="mode-title">Social Graph</div>
                            <div class="mode-desc">Friends of friends</div>
                        </div>
                        <div class="mode-card" data-mode="interests">
                            <div class="mode-title">Shared Interests</div>
                            <div class="mode-desc">Hashtag matching</div>
                        </div>
                        <div class="mode-card" data-mode="niche">
                            <div class="mode-title">Niche Communities</div>
                            <div class="mode-desc">Specific topics</div>
                        </div>
                        <div class="mode-card" data-mode="hashtags">
                            <div class="mode-title">Hashtag Discovery</div>
                            <div class="mode-desc">Search by tags</div>
                        </div>
                    </div>
                </div>

                <div class="hashtag-search-container" id="hashtag-search">
                    <div class="hashtag-input-wrapper">
                        <input type="text" 
                               class="hashtag-input" 
                               id="hashtag-input" 
                               placeholder="Enter hashtags (e.g., bitcoin, nostr, photography)">
                        <div class="tag-suggestions" id="tag-suggestions"></div>
                    </div>

                    <div class="selected-tags" id="selected-tags"></div>

                    <div class="popular-tags">
                        <div class="popular-tags-label" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>Popular Tags</span>
                            <button onclick="renderPopularTags()" style="font-size: 0.7rem; padding: 0.25rem 0.75rem; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 1rem; cursor: pointer; font-family: 'JetBrains Mono', monospace;"> Shuffle</button>
                        </div>
                        <div class="popular-tags-grid" id="popular-tags"></div>
                    </div>
                </div>

                <div class="toggle-group">
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-spam" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide Spam</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-nsfw" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide NSFW</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-following" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide Already Following</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="recent-activity-only" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Posted Within a Month</span>
    </div>
</div>

                <div class="filter-row">
                    <div class="input-group">
                        <label for="min-followers">Min Network Size</label>
                        <select id="min-followers">
                            <option value="0">Any Size</option>
                            <option value="10">Small (10+)</option>
                            <option value="50">Medium (50+)</option>
                            <option value="100">Large (100+)</option>
                            <option value="500">Very Large (500+)</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="activity-level">Activity Level</label>
                        <select id="activity-level">
                            <option value="any">Any Activity</option>
                            <option value="high">Very Active</option>
                            <option value="medium">Moderately Active</option>
                            <option value="low">Occasional</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="result-count">Results</label>
                        <select id="result-count">
                            <option value="10">10 Profiles</option>
                            <option value="25">25 Profiles</option>
                            <option value="50">50 Profiles</option>
                        </select>
                    </div>
                </div>

                <button class="btn-primary" id="find-btn">Discover Frens</button>
            </section>


            <section class="results-section" id="results-section">
                <div class="results-header">
    <h2>Discovered Frens</h2>
    <div class="results-info">
        <span class="results-count" id="results-count">0 matches</span>
    </div>
</div>
                <div class="results-grid" id="results-grid"></div>

                <div class="already-following-section" id="following-section" style="display: none;">
                    <div class="following-header" id="following-header">
                        <h3>People You Already Follow</h3>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span class="following-count" id="following-count">0</span>
                            <span class="following-toggle-icon" id="following-icon">▼</span>
                        </div>
                    </div>
                    <div class="following-content" id="following-content">
                        <div class="results-grid" id="following-grid"></div>
                    </div>
                </div>
            </section>

            <section id="empty-state" class="empty-state">
                <h3>Discover Your Frens</h3>
                <p>Choose a discovery mode and find people based on multiple matching signals</p>
            </section>
            </div>
        </main>

        <!-- Nsec Login Modal -->
        <div class="nsec-modal" id="nsec-modal">
            <div class="nsec-modal-content">
                <div class="nsec-modal-header">
                    <h3>Login with Private Key</h3>
                    <button class="nsec-close" id="nsec-close">×</button>
                </div>
                
                <div class="nsec-warning">
                    <strong>CRITICAL SECURITY NOTICE:</strong>
                    Your private key is NEVER saved, stored, or transmitted<br>
                    It only exists in browser memory during this session<br>
                    Auto-logout after 15 minutes of inactivity<br>
                    Immediately cleared when you logout or close this page<br>
                    For maximum security, use a browser extension instead<br>
                    Only use this on trusted devices you control<br>
                    Never enter your nsec on public/shared computers
                </div>

                <div class="nsec-input-group">
                    <label for="nsec-input-field">Enter your nsec private key</label>
                    <input type="password" 
                           class="nsec-input" 
                           id="nsec-input-field" 
                           placeholder="nsec1..."
                           autocomplete="off"
                           spellcheck="false">
                </div>

                <div class="nsec-actions">
                    <button class="nsec-btn nsec-btn-secondary" id="nsec-cancel">Cancel</button>
                    <button class="nsec-btn nsec-btn-primary" id="nsec-login">Login</button>
                </div>
            </div>
        </div>

        <footer>
            <p>Fren Finder - Advanced Discovery for Nostr</p>
        </footer>
    </div>

   <script type="module">
  import * as NostrTools from "https://esm.sh/nostr-tools@2.7.2";

  window.NostrTools = NostrTools;
</script>

<script>
const profileCache = new Map();  
const noteCache = new Map();
let currentUser = null;
let userFollowing = new Set();
let discoveryMode = 'social';
let nsecSecretKey = null;
let nsecInactivityTimer = null;
let lastActivityTime = Date.now();
let currentAbortController = null;

let modeSessionId = 0;   // NEW — used to isolate async work between modes

// SECURITY: Track user activity for auto-logout
function resetInactivityTimer() {
    lastActivityTime = Date.now();
    
    // Only set timer if user is logged in with nsec
    if (currentUser && currentUser.loginMethod === 'nsec') {
        if (nsecInactivityTimer) {
            clearTimeout(nsecInactivityTimer);
        }
        
        nsecInactivityTimer = setTimeout(() => {
            console.log('Auto-logout due to 15 minutes of inactivity');
            logout();
            alert('You were logged out for security after 15 minutes of inactivity');
        }, 15 * 60 * 1000); // 15 minutes
    }
}

// Track activity events
const activityEvents = ['mousedown', 'keydown', 'scroll', 'touchstart', 'click'];
activityEvents.forEach(event => {
    document.addEventListener(event, () => {
        if (currentUser && currentUser.loginMethod === 'nsec') {
            resetInactivityTimer();
        }
    }, { passive: true });
});

// SECURITY: Clear nsec from memory when page unloads
let relayHealthCheck = null; // Declare globally so beforeunload can access it
window.addEventListener('beforeunload', function() {
    if (nsecSecretKey) {
        nsecSecretKey.fill(0);
        nsecSecretKey = null;
    }
    // Also clear any inactivity timers
    if (nsecInactivityTimer) {
        clearTimeout(nsecInactivityTimer);
        nsecInactivityTimer = null;
    }
    // Clean up relay health check
    if (relayHealthCheck) {
        clearInterval(relayHealthCheck);
        relayHealthCheck = null;
    }
});

// SECURITY: Also logout when tab is hidden for extended period
document.addEventListener('visibilitychange', function() {
    if (document.hidden && currentUser && currentUser.loginMethod === 'nsec') {
        console.log('Tab hidden - inactivity timer continues');
        // Timer is already running from resetInactivityTimer
    } else if (!document.hidden && currentUser && currentUser.loginMethod === 'nsec') {
        // When tab becomes visible, check if we've been inactive too long
        const inactiveTime = Date.now() - lastActivityTime;
        if (inactiveTime > 15 * 60 * 1000) {
            console.log('Auto-logout - inactive for more than 15 minutes');
            logout();
            alert('You were logged out for security after 15 minutes of inactivity');
        } else {
            console.log('Tab visible again - resetting timer');
            resetInactivityTimer();
        }
    }
});

window.addEventListener('load', async function() {
    if (typeof NostrTools === 'undefined') {
        alert('Failed to load Nostr tools');
        return;
    }

    const { nip19, SimplePool } = NostrTools;
    let pool = new SimplePool();
window._nostrPool = pool;
    const RELAYS = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://nos.lol','wss://relay.nostr.band'];

    function resetRelayPool() {
  console.log("🔄 Resetting relay pool and aborting pending queries...");

  if (currentAbortController) {
    currentAbortController.abort();
    currentAbortController = null;
  }

  try {
    pool = new NostrTools.SimplePool();   // ✅ THIS is what your functions use
    window._nostrPool = pool;
    console.log("✅ New SimplePool created safely.");
  } catch (err) {
    console.warn("Pool reset error:", err);
  }
}

    // Theme toggle
    document.getElementById('theme-btn').addEventListener('click', () => {
        const html = document.documentElement;
        const theme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
        html.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
    });
    document.documentElement.setAttribute('data-theme', localStorage.getItem('theme') || 'light');

    // Spam detection
    function detectSpam(profile, notes) {
        let spamScore = 0;
        const name = (profile.name || '').toLowerCase();
        const about = (profile.about || '').toLowerCase();
        
        const spamPhrases = ['hello world', 'test test', 'testing 123', 'this is a test', 'hello nostr', 'first post', 'new here'];
        
        for (const phrase of spamPhrases) {
            if (about.includes(phrase) && about.length < 50) spamScore += 30;
        }
        
        if (about.length === 0) spamScore += 20;
        if (about.length > 0 && about.length < 10) spamScore += 15;
        if (name.match(/^user\d+$/i)) spamScore += 25;
        if (name.match(/^anon\d+$/i)) spamScore += 20;
        if (name === 'anon' || name === '') spamScore += 10;
        if (!profile.picture) spamScore += 10;
        if (notes && notes.length === 0) spamScore += 20;
        if (notes && notes.length === 1) spamScore += 10;
        
        if (notes && notes.length > 1) {
            const contents = notes.map(n => n.content.toLowerCase());
            const uniqueContents = new Set(contents);
            if (uniqueContents.size < notes.length / 2) spamScore += 15;
        }
        
        return spamScore;
    }

    function detectNSFW(profile, notes) {
    const about = (profile.about || '').toLowerCase();
    const name = (profile.name || '').toLowerCase();

    // Expanded NSFW triggers
    const nsfwKeywords = [
        'nsfw', 'xxx', '18+', 'porn', 'onlyfans', 'nude', 
        'nudes', 'erotic', 'adult content', '🔞', 'hentai', 'camgirl', 'explicit'
    ];

    // Helper to check text for NSFW indicators
    function containsNSFW(text) {
        if (!text) return false;
        const lower = text.toLowerCase();
        return nsfwKeywords.some(keyword => lower.includes(keyword));
    }

    // Check bio + name
    if (containsNSFW(about) || containsNSFW(name)) {
        return true;
    }

    // Check content warnings in tags
    if (notes && notes.length > 0) {
        for (const note of notes) {
            const content = (note.content || '').toLowerCase();

            // Check text content including emoji
            if (containsNSFW(content)) return true;

            // Check t-tags for NSFW words
            const tagList = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
            for (const tag of tagList) {
                if (containsNSFW(tag)) return true;
            }

            // Check for explicit content-warning tag
            const contentWarnings = note.tags?.filter(t => t[0] === 'content-warning') || [];
            if (contentWarnings.length > 0) return true;
        }
    }

    return false;
}

function detectDeletedAccount(profile, notes, follows) {
    // 1. If no profile data at all
    if (!profile || profile.name === undefined) {
        return false; // Just treat as anonymous, not deleted
    }

    const name = (profile.name || '').toLowerCase();
    const about = (profile.about || '').toLowerCase();

    // 2. Only mark as deleted if VERY explicit
    if (name === 'deleted' || name === '[deleted]' || name === 'deactivated') {
        return true;
    }
    
    if (about === 'deleted' || about === '[deleted]' || about === 'account deactivated') {
        return true;
    }

    // 3. Don't mark as deleted for inactivity or minimal profiles
    // Many active users have minimal profiles
    
    return false;
}

    // Discovery mode selection
document.querySelectorAll('.mode-card').forEach(card => {
    card.addEventListener('click', function() {
        // Abort any ongoing search
        if (currentAbortController) {
            currentAbortController.abort();
            currentAbortController = null;

            const findBtn = document.getElementById('find-btn');
            findBtn.disabled = false;
            findBtn.textContent = 'Discover Frens';
        }

        // UI highlight
        document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('active'));
        this.classList.add('active');
        discoveryMode = this.dataset.mode;

        // Show hashtag input only when needed
        const hashtagSearch = document.getElementById('hashtag-search');
        if (discoveryMode === 'hashtags') {
            hashtagSearch.classList.add('visible');
        } else {
            hashtagSearch.classList.remove('visible');
            
            // Clear selected hashtags when leaving hashtag mode
            selectedHashtags.clear();
            renderSelectedTags();
        }
        
        // Reset cross-reference UI if not enabled
        if (!crossRefEnabled) {
            document.getElementById('cross-ref-input').classList.remove('visible');
            document.getElementById('comparison-results').classList.remove('visible');
        }
    });
});

    // Hashtag setup
    const selectedHashtags = new Set();
    const matchMode = 'all'; // Always match ALL tags for cleaner UX

    const POPULAR_TAGS = ['bitcoin', 'nostr', 'lightning', 'crypto', 'privacy', 'art', 'photography', 'music', 'writing', 'design', 'coding', 'tech', 'ai', 'web3', 'freedom', 'travel', 'food', 'fitness', 'nature', 'coffee', 'startup', 'business', 'marketing', 'trading', 'investing'];

    function renderPopularTags() {
        const container = document.getElementById('popular-tags');
        container.innerHTML = '';
        
        // Sample 5 random tags
        const shuffled = [...POPULAR_TAGS].sort(() => Math.random() - 0.5);
        const sampled = shuffled.slice(0, 5);
        
        sampled.forEach(tag => {
            const tagEl = document.createElement('div');
            tagEl.className = 'popular-tag';
            tagEl.textContent = `#${tag}`;
            tagEl.addEventListener('click', () => addHashtag(tag));
            container.appendChild(tagEl);
        });
    }
    window.renderPopularTags = renderPopularTags; // Make globally accessible for shuffle button
    renderPopularTags();

    function addHashtag(tag) {
        const normalized = tag.toLowerCase().replace(/^#/, '');
        if (!selectedHashtags.has(normalized)) {
            selectedHashtags.add(normalized);
            renderSelectedTags();
        }
        document.getElementById('hashtag-input').value = '';
        document.getElementById('tag-suggestions').classList.remove('visible');
    }

    document.getElementById('hashtag-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            e.stopPropagation();
            const tag = e.target.value.trim();
            if (tag) addHashtag(tag);
        }
    });

    function removeHashtag(tag) {
        selectedHashtags.delete(tag);
        renderSelectedTags();
    }

    function renderSelectedTags() {
        const container = document.getElementById('selected-tags');
        container.innerHTML = '';
        
        if (selectedHashtags.size === 0) {
            container.innerHTML = '<div style="color: var(--text-tertiary); font-style: italic;">No tags selected</div>';
            return;
        }

        selectedHashtags.forEach(tag => {
            const tagEl = document.createElement('div');
            tagEl.className = 'selected-tag';
            tagEl.innerHTML = `#${tag}<span class="tag-remove" onclick="removeHashtag('${tag}')">×</span>`;
            container.appendChild(tagEl);
        });
    }
    renderSelectedTags();

    window.removeHashtag = removeHashtag;

    // Cross-reference
    let crossRefEnabled = false;
    let crossRefData = null;

    document.getElementById('enable-cross-ref').addEventListener('change', function() {
        crossRefEnabled = this.checked;
        const crossRefInput = document.getElementById('cross-ref-input');
        const comparisonResults = document.getElementById('comparison-results');
        
        if (crossRefEnabled) {
            crossRefInput.classList.add('visible');
        } else {
            crossRefInput.classList.remove('visible');
            comparisonResults.classList.remove('visible');
            crossRefData = null;
        }
    });

    document.getElementById('cross-ref-input').addEventListener('blur', async function() {
        const crossRefNpub = this.value.trim();
        
        if (!crossRefNpub || !crossRefNpub.startsWith('npub1')) return;

        const mainNpub = document.getElementById('npub-input').value.trim();
        if (!mainNpub || !mainNpub.startsWith('npub1')) {
            alert('Please enter your main npub first');
            return;
        }

        try {
            const { data: mainPubkey } = nip19.decode(mainNpub);
            const { data: crossPubkey } = nip19.decode(crossRefNpub);

            const mainFollows = await fetchFollows(mainPubkey);
            const crossFollows = await fetchFollows(crossPubkey);

            const mainSet = new Set(mainFollows);
            const crossSet = new Set(crossFollows);

            const youOnly = mainFollows.filter(p => !crossSet.has(p));
            const themOnly = crossFollows.filter(p => !mainSet.has(p));
            const mutual = mainFollows.filter(p => crossSet.has(p));

            crossRefData = { youOnly, themOnly, mutual };

            document.getElementById('you-only-count').textContent = youOnly.length;
            document.getElementById('mutual-count').textContent = mutual.length;
            document.getElementById('them-only-count').textContent = themOnly.length;
            document.getElementById('comparison-results').classList.add('visible');
        } catch (err) {
            console.error('Cross-reference error:', err);
            alert('Failed to analyze cross-reference');
        }
    });

    // Login functions
    async function loginWithExtension() {
        if (typeof window.nostr === 'undefined') {
            alert('Please install a Nostr browser extension (Alby, nos2x)');
            return null;
        }

        try {
            const pubkey = await window.nostr.getPublicKey();
            const npub = nip19.npubEncode(pubkey);
            const profile = await fetchProfile(pubkey);
            currentUser = { pubkey, npub, profile, loginMethod: 'extension' };
            const follows = await fetchFollows(pubkey);
            userFollowing = new Set(follows);
            updateUserUI();
            document.getElementById('npub-input').value = npub;
            document.getElementById('npub-input').disabled = true;
            return npub;
        } catch (err) {
            console.error('Login error:', err);
            alert('Failed to login');
            return null;
        }
    }

    function showNsecModal() {
        const modal = document.getElementById('nsec-modal');
        const input = document.getElementById('nsec-input-field');
        input.value = '';
        modal.classList.add('visible');
        input.focus();
    }

    function hideNsecModal() {
        const modal = document.getElementById('nsec-modal');
        const input = document.getElementById('nsec-input-field');
        input.value = '';
        modal.classList.remove('visible');
    }

    async function loginWithNsec() {
        const input = document.getElementById('nsec-input-field');
        const nsecString = input.value.trim();

        if (!nsecString) {
            alert('Please enter your nsec');
            return null;
        }

        if (!nsecString.startsWith('nsec1')) {
            alert('Invalid nsec format. Must start with nsec1');
            input.value = '';
            return null;
        }

        try {
            const { data: secretKey } = nip19.decode(nsecString);
            
            if (secretKey.length !== 32) {
                throw new Error('Invalid secret key length');
            }
            
            input.value = '';
            
            const pubkey = NostrTools.getPublicKey(secretKey);
            const npub = nip19.npubEncode(pubkey);
            
            nsecSecretKey = secretKey;
            
            const profile = await fetchProfile(pubkey);
            currentUser = { pubkey, npub, profile, loginMethod: 'nsec' };
            const follows = await fetchFollows(pubkey);
            userFollowing = new Set(follows);
            
            updateUserUI();
            document.getElementById('npub-input').value = npub;
            document.getElementById('npub-input').disabled = true;
            
            document.getElementById('nsec-warning-banner').classList.add('visible');
            
            hideNsecModal();
            
            // Start inactivity timer
            resetInactivityTimer();
            
            console.log('Nsec login successful - key stored in memory only');
            return npub;
        } catch (err) {
            console.error('Nsec login error:', err);
            input.value = '';
            alert('Failed to login with nsec. Please check your private key format.');
            return null;
        }
    }

    function logout() {
        currentUser = null;
        userFollowing.clear();
        
        if (nsecInactivityTimer) {
            clearTimeout(nsecInactivityTimer);
            nsecInactivityTimer = null;
        }
        
        if (nsecSecretKey) {
            for (let i = 0; i < nsecSecretKey.length; i++) {
                nsecSecretKey[i] = 0;
            }
            nsecSecretKey = null;
        }
        
        document.getElementById('nsec-warning-banner').classList.remove('visible');
        
        document.getElementById('npub-input').value = '';
        document.getElementById('npub-input').disabled = false;
        updateUserUI();
    }

    async function followUser(targetPubkey) {
    if (!currentUser || !currentUser.pubkey) {
        alert('You must be logged in to follow users.');
        return false;
    }

    try {
        const existingFollows = await fetchFollows(currentUser.pubkey);

        if (existingFollows.includes(targetPubkey)) {
            console.log('Already following:', targetPubkey);
            return true;
        }

        const newFollows = [...existingFollows, targetPubkey];

        const event = {
            kind: 3,
            pubkey: currentUser.pubkey,
            created_at: Math.floor(Date.now() / 1000),
            tags: newFollows.map(pk => ['p', pk]),
            content: ''
        };

        let signedEvent;
        if (currentUser.loginMethod === 'extension') {
            signedEvent = await window.nostr.signEvent(event);
        } else if (currentUser.loginMethod === 'nsec' && nsecSecretKey) {
            signedEvent = NostrTools.finalizeEvent(event, nsecSecretKey);
        } else {
            throw new Error('No signing method available');
        }

        await pool.publish(RELAYS, signedEvent);

        userFollowing.add(targetPubkey);
        followsCache.set(currentUser.pubkey, newFollows);

        console.log('✅ Followed user:', targetPubkey);
        return true;

    } catch (err) {
        console.error('Follow failed:', err);
        alert('Failed to follow user.');
        return false;
    }
}

    function updateUserUI() {
        const userSection = document.getElementById('user-section');
        const npubInput = document.getElementById('npub-input');

        if (currentUser) {
            if (currentUser.npub) {
                npubInput.value = currentUser.npub;
                npubInput.disabled = true;
            }

            const name = currentUser.profile?.name || 'Anon';
            const picture = currentUser.profile?.picture || `https://robohash.org/${currentUser.pubkey}?set=set5`;
            
            userSection.innerHTML = `
                <div class="user-info-combined" id="user-info-logout">
                    <img src="${picture}" class="user-avatar" onerror="this.src='https://robohash.org/${currentUser.pubkey}?set=set5'">
                    <div class="user-details">
                        <span class="user-name">${name}</span>
                        <span class="user-action">Logout</span>
                    </div>
                </div>
            `;
            document.getElementById('user-info-logout').addEventListener('click', logout);
        } else {
            npubInput.value = '';
            npubInput.disabled = false;

            userSection.innerHTML = `
                <div class="login-dropdown">
                    <button class="btn btn-login" id="login-btn">Login</button>
                    <div class="login-menu" id="login-menu">
                        <div class="login-option" id="extension-login">Extension Login</div>
                        <div class="login-option" id="nsec-login-option">Private Key (nsec)</div>
                    </div>
                </div>
            `;
            
            const loginBtn = document.getElementById('login-btn');
            const loginMenu = document.getElementById('login-menu');
            
            loginBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                loginMenu.classList.toggle('visible');
            });
            
            document.getElementById('extension-login').addEventListener('click', function() {
                loginMenu.classList.remove('visible');
                loginWithExtension();
            });
            
            document.getElementById('nsec-login-option').addEventListener('click', function() {
                loginMenu.classList.remove('visible');
                showNsecModal();
            });
            
            document.addEventListener('click', function() {
                loginMenu.classList.remove('visible');
            });
        }
    }

    // Helper function for relay queries
async function queryRelays(relays, filter, timeout = 10000, session = null) {
    if (session !== modeSessionId) return []; // 🚫 ignore stale queries

    try {
        currentAbortController = new AbortController();
        const signal = currentAbortController.signal;

        const events = await pool.querySync(relays, filter, { signal });

        if (session !== modeSessionId) return []; // 🚫 still stale after await

        return events || [];
    } catch (err) {
        console.warn('Query error:', err.message);
        return [];
    }
}

   async function fetchProfilesBatch(pubkeys, session) {
  const results = new Map();

  // Seed from cache
  pubkeys.forEach(pk => {
    if (profileCache.has(pk)) {
      results.set(pk, profileCache.get(pk));
    }
  });

  const toFetch = pubkeys.filter(pk => !results.has(pk));
  if (toFetch.length === 0) {
    return pubkeys.map(pk => results.get(pk));
  }

  const BATCH_SIZE = 10; // 🔑 critical
  for (let i = 0; i < toFetch.length; i += BATCH_SIZE) {
    if (session !== modeSessionId) break;

    const batch = toFetch.slice(i, i + BATCH_SIZE);

    let events = [];
    try {
      events = await pool.querySync(
        ['wss://purplepag.es', ...RELAYS], // force purplepages first
        { kinds: [0], authors: batch }
      );
    } catch (e) {
      console.warn('Profile batch failed:', e.message);
    }

    // newest profile per pubkey
    events.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));
    const seen = new Set();

    for (const e of events) {
      if (seen.has(e.pubkey)) continue;
      seen.add(e.pubkey);

      let raw = {};
      try { raw = JSON.parse(e.content || '{}'); } catch {}

      const profile = {
        pubkey: e.pubkey,
        name: raw.name || 'Anonymous',
        about: raw.about || '',
        picture: raw.picture || `https://robohash.org/${e.pubkey}?set=set5`,
        hasMetadata: true
      };

      profileCache.set(e.pubkey, profile);
      results.set(e.pubkey, profile);
    }

    // fallback for missing metadata
    batch.forEach(pk => {
      if (!results.has(pk)) {
        results.set(pk, {
          pubkey: pk,
          name: 'Anonymous',
          about: '',
          picture: `https://robohash.org/${pk}?set=set5`,
          hasMetadata: false
        });
      }
    });

    // small delay to avoid relay throttling
    await new Promise(r => setTimeout(r, 80));
  }

  return pubkeys.map(pk => results.get(pk));
}

  // FIXED: Fetch notes individually per user in small batches
async function fetchNotesBatch(pubkeys, limit = 100, session) {

    const uncachedPubkeys = pubkeys;
    console.log(`Fetching notes for ${uncachedPubkeys.length} users (${limit} per user)...`);

    const BATCH_SIZE = 20;
    const allResults = [];

    for (let i = 0; i < uncachedPubkeys.length; i += BATCH_SIZE) {

        const batch = uncachedPubkeys.slice(i, i + BATCH_SIZE);

        const batchPromises = batch.map(async (pubkey) => {
            try {

                const events = await pool.querySync(RELAYS, {
                    kinds: [1],
                    authors: [pubkey],
                    since: Math.floor(Date.now() / 1000) - 30 * 24 * 60 * 60,
                    limit: limit
                });

                // NEW — session guard right after await
                if (session !== modeSessionId) return [];

                const sorted = events.sort((a, b) => b.created_at - a.created_at);
                noteCache.set(pubkey, sorted);
                return { pubkey, notes: sorted };

            } catch (err) {
                console.error(`Error fetching notes for ${pubkey}:`, err);
                noteCache.set(pubkey, []);
                return { pubkey, notes: [] };
            }
        });

        const batchResults = await Promise.all(batchPromises);

        // NEW — must stop if session changed while promises resolved
        if (session !== modeSessionId) return [];

        allResults.push(...batchResults);

        if (i + BATCH_SIZE < uncachedPubkeys.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
            // Optional: add guard here too
            if (session !== modeSessionId) return [];
        }
    }

    console.log(`Fetched notes for ${allResults.length} users`);
    const withNotes = allResults.filter(r => r.notes.length > 0).length;
    const with3Plus = allResults.filter(r => r.notes.length >= 3).length;
    console.log(`Users with notes: ${withNotes}, with 3+: ${with3Plus}`);

    return pubkeys.map(pk => noteCache.get(pk) || []);
}

    const followsCache = new Map(); // pubkey -> array

async function fetchFollowsBatch(pubkeys) {
  console.log(`Fetching follows for ${pubkeys.length} users...`);

  // Seed results from cache (optional but helpful)
  const followMap = new Map();
  pubkeys.forEach(pk => followMap.set(pk, followsCache.get(pk) || []));

  try {
    const events = await pool.querySync(RELAYS, {
      kinds: [3],
      authors: pubkeys
    });

    // IMPORTANT: newest first so we keep the most recent contacts list
    events.sort((a, b) => (b.created_at || 0) - (a.created_at || 0));

    const seen = new Set();

    for (const event of events) {
      const pk = event.pubkey;
      if (seen.has(pk)) continue; // only use newest event per pubkey
      seen.add(pk);

      const follows = (event.tags || [])
        .filter(t => t[0] === 'p' && t[1])
        .map(t => t[1]);

      // KEY: do NOT overwrite a non-empty cached/list with an empty event
      if (follows.length > 0) {
        followMap.set(pk, follows);
        followsCache.set(pk, follows);
      } else {
        // keep whatever we already had (cache/previous)
        // (do nothing)
      }
    }

    return pubkeys.map(pk => followMap.get(pk) || []);
  } catch (err) {
    console.error("Batch follows fetch error:", err);
    return pubkeys.map(pk => followsCache.get(pk) || []);
  }
}

    async function fetchProfile(pubkeyHex, session = null) {
    if (profileCache.has(pubkeyHex)) {
        return profileCache.get(pubkeyHex);
    }

    const [profile] = await fetchProfilesBatch([pubkeyHex], session);

    return profile || null;
}

    async function fetchRecentNotes(pubkeyHex, limit = 100, session = null) {
  if (noteCache.has(pubkeyHex)) {
    return noteCache.get(pubkeyHex) || [];
  }

  const results = await fetchNotesBatch([pubkeyHex], limit, session);

  if (!Array.isArray(results) || !Array.isArray(results[0])) return [];
  return results[0];
}

    async function fetchFollows(pubkeyHex) {
  if (followsCache.has(pubkeyHex)) return followsCache.get(pubkeyHex);
  const [follows] = await fetchFollowsBatch([pubkeyHex]);
  return follows || [];
}

    async function fetchFollowsSafe(pubkeyHex, session) {
    // Ignore stale calls
    if (session !== modeSessionId) return null;

    const [follows] = await fetchFollowsBatch([pubkeyHex]);

    // Ignore if mode changed while awaiting relays
    if (session !== modeSessionId) return null;

    return follows;
}

async function debugMyFollows(pubkey) {
    console.log('🧪 DEBUG: Inspecting kind:3 events for your pubkey');

    const events = await pool.querySync(RELAYS, {
        kinds: [3],
        authors: [pubkey],
        limit: 10
    });

    events
        .sort((a, b) => (b.created_at || 0) - (a.created_at || 0))
        .forEach((e, i) => {
            const pCount = (e.tags || []).filter(t => t[0] === 'p').length;
            console.log(
                `  #${i + 1}`,
                'created_at:', e.created_at,
                'p-tags:', pCount,
                'relay event id:', e.id.slice(0, 8)
            );
        });
}

async function getGlobalCandidates({
  relays,
  userPubkey,
  userFollows,
  resultCount,
  session,
  hoursBack = 72,        // sample last 3 days
  eventLimit = 5000,     // how many notes to pull total
  minNotesPerUser = 2,   // require at least 2 notes in sample
  excludeFollowed = true // don't show people you already follow
}) {
  if (session !== modeSessionId) return [];

  const since = Math.floor(Date.now() / 1000) - hoursBack * 3600;

  console.log(`🌍 GLOBAL: Sampling notes since last ${hoursBack}h...`);

  let events = [];
  try {
    // Use your existing pool directly (queryRelays also works, but yours uses abort/session logic)
    events = await pool.querySync(relays, {
      kinds: [1],
      since,
      limit: eventLimit
    });
  } catch (err) {
    console.warn("GLOBAL query failed:", err.message);
    return [];
  }

  if (session !== modeSessionId) return [];

  // Count notes per author from the sample
  const counts = new Map();
  for (const e of events) {
    if (!e?.pubkey) continue;
    if (e.pubkey === userPubkey) continue;

    // optional: exclude followed people
    if (excludeFollowed && userFollows?.includes(e.pubkey)) continue;

    counts.set(e.pubkey, (counts.get(e.pubkey) || 0) + 1);
  }

  // Filter authors by min activity in the sample
  let candidates = Array.from(counts.entries())
    .filter(([_, c]) => c >= minNotesPerUser)
    .sort((a, b) => b[1] - a[1]) // most active in sample first
    .map(([pk]) => pk);

  if (candidates.length === 0) {
    console.log("GLOBAL: No candidates after filtering");
    return [];
  }

  // Add randomness so you don’t always get the same people
  candidates = candidates.sort(() => Math.random() - 0.5);

  // Overfetch so later filters (spam/nsfw/etc) still leave enough results
  const overfetch = resultCount * 4;
  candidates = candidates.slice(0, overfetch);

  console.log(`🌍 GLOBAL: Returning ${candidates.length} candidate pubkeys`);
  return candidates;
}
    
async function searchUsersByHashtags(hashtags, limit = 50, session) {
    if (session !== modeSessionId) return [];  
    console.log('🔍 HASHTAG DISCOVERY: Searching all posts for hashtags:', Array.from(hashtags));
    
    const userCandidates = new Map();
    const hashtagArray = Array.from(hashtags);
    
    if (hashtagArray.length === 0) {
        console.log('No hashtags to search for');
        return [];
    }
    
    try {
        for (const tag of hashtagArray) {
            console.log('Searching for #' + tag);
            
            try {
                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);
                
                const events = await pool.querySync(RELAYS, {
                    kinds: [1],
                    '#t': [tag.toLowerCase()],
                    limit: 100
                });
                
                clearTimeout(timeoutId);
                console.log(`Found ${events.length} posts for #${tag}`);
                
                // Count users by how many matching posts they have
                events.forEach(event => {
                    const count = userCandidates.get(event.pubkey) || 0;
                    userCandidates.set(event.pubkey, count + 1);
                });
            } catch (err) {
                console.warn(`Error searching for #${tag}:`, err.message);
            }

            // Check session after each iteration
            if (session !== modeSessionId) return [];
            
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // Sort and filter
        const sortedUsers = Array.from(userCandidates.entries())
            .sort((a, b) => b[1] - a[1])
            .slice(0, limit * 2);
        
        console.log(`✅ Returning top ${sortedUsers.length} users for analysis`);
        
        if (session !== modeSessionId) return [];
        return sortedUsers.map(([pubkey]) => pubkey);
    } catch (err) {
        console.error('Hashtag search error:', err);
        return [];
    }
}

    // DEDICATED: Fetch notes for interests/niche modes (ALL TIME, no time limit)
async function fetchNotesForHashtagModes(pubkeys, limit = 100) {
    console.log(`🔄 DEDICATED: Fetching ALL-TIME notes for ${pubkeys.length} users...`);

    const BATCH_SIZE = 10; // Smaller batch for better relay handling
    const allResults = [];

    for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
        const batch = pubkeys.slice(i, i + BATCH_SIZE);
        
        const batchPromises = batch.map(async (pubkey) => {
            try {
                // NO time filter - get ALL notes
                const events = await pool.querySync(RELAYS, {
                    kinds: [1],
                    authors: [pubkey],
                    limit: limit
                });
                
                const sorted = events.sort((a, b) => b.created_at - a.created_at);
                noteCache.set(pubkey, sorted);
                return { pubkey, notes: sorted };
            } catch (err) {
                console.error(`Error fetching notes for ${pubkey}:`, err);
                noteCache.set(pubkey, []);
                return { pubkey, notes: [] };
            }
        });

        const batchResults = await Promise.all(batchPromises);
        allResults.push(...batchResults);

        // Longer delay to avoid relay rate limiting
        if (i + BATCH_SIZE < pubkeys.length) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }

    console.log(`✅ DEDICATED: Fetched ALL-TIME notes for ${allResults.length} users`);
    const withNotes = allResults.filter(r => r.notes.length > 0).length;
    const with3Plus = allResults.filter(r => r.notes.length >= 3).length;
    console.log(`Users with notes: ${withNotes}, with 3+: ${with3Plus}`);

    return pubkeys.map(pk => noteCache.get(pk) || []);
}



// DEDICATED: Fetch notes for social mode (RECENT only)
async function fetchNotesForSocialMode(pubkeys, limit = 100) {
    console.log(`🔄 DEDICATED: Fetching RECENT notes for ${pubkeys.length} users...`);

    const BATCH_SIZE = 10;
    const allResults = [];

    for (let i = 0; i < pubkeys.length; i += BATCH_SIZE) {
        const batch = pubkeys.slice(i, i + BATCH_SIZE);
        
        const batchPromises = batch.map(async (pubkey) => {
            try {
                // 30-day time filter for social mode
                const events = await pool.querySync(RELAYS, {
                    kinds: [1],
                    authors: [pubkey],
                    since: Math.floor(Date.now() / 1000) - 30 * 24 * 60 * 60,
                    limit: limit
                });
                
                const sorted = events.sort((a, b) => b.created_at - a.created_at);
                noteCache.set(pubkey, sorted);
                return { pubkey, notes: sorted };
            } catch (err) {
                console.error(`Error fetching notes for ${pubkey}:`, err);
                noteCache.set(pubkey, []);
                return { pubkey, notes: [] };
            }
        });

        const batchResults = await Promise.all(batchPromises);
        allResults.push(...batchResults);

        if (i + BATCH_SIZE < pubkeys.length) {
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }

    console.log(`✅ DEDICATED: Fetched RECENT notes for ${allResults.length} users`);
    const withNotes = allResults.filter(r => r.notes.length > 0).length;
    const with3Plus = allResults.filter(r => r.notes.length >= 3).length;
    console.log(`Users with notes: ${withNotes}, with 3+: ${with3Plus}`);

    return pubkeys.map(pk => noteCache.get(pk) || []);
}

function extractHashtagsFromNote(note) {
    const tags = new Set();

    // 1. Proper Nostr t-tags
    const tTags = note.tags
        ?.filter(t => t[0] === 't' && t[1])
        .map(t => t[1].toLowerCase()) || [];
    tTags.forEach(t => tags.add(t));

    // 2. Inline hashtags from content
    const contentTags = note.content
        ?.match(/#([a-zA-Z0-9_]+)/g) || [];
    contentTags.forEach(t => tags.add(t.slice(1).toLowerCase()));

    return tags;
}

    async function discoverByInterests(userPubkey, userFollows, limit, session) {
    if (session !== modeSessionId) return [];

    console.log('🎯 INTERESTS MODE: discovering via your own hashtags');

    // 1. Fetch ONLY your recent notes
    const myNotes = (await fetchRecentNotes(userPubkey, 50, session)) || [];
    if (session !== modeSessionId) return [];

    // 2. Extract hashtags YOU actually used
    const myTags = new Set();

myNotes.forEach(note => {
    extractHashtagsFromNote(note).forEach(tag => {
        myTags.add(tag);
    });
});

    if (myTags.size === 0) {
        console.log('⚠️ No hashtags found — fallback to social');
        return getRecommendations(userPubkey, userFollows, limit, session);
    }

    // 3. Randomly select 2–3 hashtags YOU used
    const shuffled = [...myTags].sort(() => Math.random() - 0.5);
    const selectedTags = shuffled.slice(0, Math.min(3, shuffled.length));

    console.log('🔖 Using hashtags:', selectedTags);

    // 4. Search other users using those hashtags
    const candidates = new Map();

    for (const tag of selectedTags) {
        if (session !== modeSessionId) return [];

        const events = await pool.querySync(RELAYS, {
            kinds: [1],
            '#t': [tag],
            limit: 200
        });

        events.forEach(e => {
            if (!e.pubkey) return;
            if (e.pubkey === userPubkey) return;
            if (userFollows.includes(e.pubkey)) return;

            candidates.set(e.pubkey, (candidates.get(e.pubkey) || 0) + 1);
        });

        await new Promise(r => setTimeout(r, 150)); // relay friendly
    }

    // 5. Rank users by shared hashtag usage
    const sorted = [...candidates.entries()]
        .sort((a, b) => b[1] - a[1])
        .map(([pk]) => pk);

    // 6. HARD LIMIT: 4× results
    const final = sorted.slice(0, limit * 4);

    console.log(`🎯 INTERESTS MODE: returning ${final.length} candidates`);
    return final;
}

// DEDICATED: Niche mode discovery
async function discoverByNiche(limit, session) {
    if (session !== modeSessionId) return [];   
    console.log('🎯 NICHE MODE: Finding users with rare/unique content...');
    
    try {
        // Get a sample of recent posts to find rare hashtags
        const recentEvents = await pool.querySync(RELAYS, {
            kinds: [1],
            limit: 300 // Smaller sample
        });
        
        // Count hashtag frequency
        const hashtagCounts = new Map();
        recentEvents.forEach(event => {
            const tags = event.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
            tags.forEach(tag => {
                hashtagCounts.set(tag, (hashtagCounts.get(tag) || 0) + 1);
            });
        });
        
        // Find rare hashtags (used 1-5 times)
        const rareHashtags = Array.from(hashtagCounts.entries())
            .filter(([tag, count]) => count >= 1 && count <= 5)
            .slice(0, 3) // Only use 3 rare hashtags
            .map(([tag]) => tag);
        
        if (rareHashtags.length === 0) {
            console.log('⚠️ No rare hashtags found');
            return [];
        }
        
        console.log(`🎯 Found ${rareHashtags.length} rare hashtags`);
        
        // Search for users with these rare hashtags
        return await searchUsersByHashtags(new Set(rareHashtags), limit * 2, session);
    } catch (err) {
        console.error('Niche discovery error:', err);
        return [];
    }
}

    // NEW: Search for users with rare/niche hashtags (niche mode)
    async function searchUsersByRareHashtags(limit = 100) {
        console.log('🔍 NICHE MODE: Finding users with rare and unique hashtags...');
        
        try {
            // First, get a broad sample of recent posts
            const recentEvents = await queryRelays(RELAYS, {
  kinds: [1],
  since: Math.floor(Date.now() / 1000) - 14 * 24 * 60 * 60,
  limit: 3000
}, 5000, session);
            
            console.log(`Analyzing ${recentEvents.length} recent posts...`);
            
            // Count hashtag popularity
            const hashtagPopularity = new Map();
            const userHashtags = new Map();
            
            recentEvents.forEach(event => {
                const tags = event.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                tags.forEach(tag => {
                    hashtagPopularity.set(tag, (hashtagPopularity.get(tag) || 0) + 1);
                    
                    if (!userHashtags.has(event.pubkey)) {
                        userHashtags.set(event.pubkey, []);
                    }
                    userHashtags.get(event.pubkey).push(tag);
                });
            });
            
            // Find rare hashtags (used by fewer than 10 people)
            const rareHashtags = Array.from(hashtagPopularity.entries())
                .filter(([tag, count]) => count >= 2 && count <= 10)
                .map(([tag]) => tag);
            
            console.log(`Found ${rareHashtags.length} rare hashtags (used 2-10 times)`);
            
            // Score users based on how many rare hashtags they use
            const userScores = new Map();
            
            userHashtags.forEach((tags, pubkey) => {
                const rareTagsUsed = tags.filter(tag => rareHashtags.includes(tag));
                if (rareTagsUsed.length > 0) {
                    userScores.set(pubkey, rareTagsUsed.length);
                }
            });
            
            // Get top users by rare hashtag usage
            const sortedUsers = Array.from(userScores.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit * 3)
                .map(([pubkey]) => pubkey);
            
            // Shuffle to add variety
            const shuffled = sortedUsers.sort(() => Math.random() - 0.5).slice(0, limit);
            
            console.log(`✓ Found ${shuffled.length} users with rare/niche content`);
            if (session !== modeSessionId) return [];
return shuffled;
        } catch (err) {
            console.error('Rare hashtags search error:', err);
            return [];
        }
    }
    

    function calculateMatchScore(
    userProfile,
    candidateProfile,
    userFollows,
    candidateFollows,
    candidateNotes,
    searchTags = null
) {
    // 🚫 Abort safely if user profile is missing or stale
    if (!userProfile || !userProfile.pubkey) {
        return {
            total: 0,
            breakdown: {
                social: 0,
                interests: 0,
                engagement: 0,
                niche: 0,
                hashtag: 0
            }
        };
    }

    let scores = {
        social: 0,
        interests: 0,
        engagement: 0,
        niche: 0,
        hashtag: 0
    };

        if (userFollows && candidateFollows) {
            const mutualFollows = candidateFollows.filter(f => userFollows.includes(f)).length;
            const followsYou = candidateFollows.includes(userProfile.pubkey);
            scores.social = Math.min(100, (mutualFollows * 10) + (followsYou ? 20 : 0));
        }

        const userBioHashtags = (userProfile.about || '').match(/#\w+/gi) || [];
        const candidateBioHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];

        const userPostHashtags = new Set();
        if (candidateNotes) {
            candidateNotes.forEach(note => {
                const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                tags.forEach(tag => userPostHashtags.add(tag));
            });
        }

        const allCandidateHashtags = [
            ...candidateBioHashtags.map(h => h.toLowerCase().replace('#', '')),
            ...Array.from(userPostHashtags)
        ];

        const sharedHashtags = userBioHashtags.filter(h => 
            allCandidateHashtags.some(ch => ch === h.toLowerCase().replace('#', ''))
        ).length;

        scores.interests = Math.min(100, sharedHashtags * 25);

        if (candidateNotes && candidateNotes.length > 0) {
            const avgNotesPerDay = candidateNotes.length / 7;
            scores.engagement = Math.min(100, avgNotesPerDay * 15);
        }

        const candidateBioTags = (candidateProfile.about || '').match(/#\w+/gi) || [];
        const candidatePostTags = new Set();
        if (candidateNotes) {
            candidateNotes.forEach(note => {
                const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                tags.forEach(tag => candidatePostTags.add(tag));
            });
        }

        const allTopics = [
            ...candidateBioTags.map(h => h.toLowerCase().replace('#', '')),
            ...Array.from(candidatePostTags)
        ];

        if (allTopics.length > 0 && window.topicPopularity) {
            const rarityScores = allTopics.map(topic => {
                const popularity = window.topicPopularity.get(topic) || 1;
                const totalProfiles = window.topicPopularity.size;
                const rarityPercent = (popularity / totalProfiles) * 100;
                return rarityPercent < 10 ? (100 - rarityPercent * 5) : 0;
            });
            
            const avgRarity = rarityScores.reduce((a, b) => a + b, 0) / rarityScores.length;
            scores.niche = Math.min(100, Math.max(0, avgRarity));
        } else {
            scores.niche = 0;
        }

        if (searchTags && searchTags.size > 0) {
            const bioHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];
            const postHashtags = new Set();
            if (candidateNotes) {
                candidateNotes.forEach(note => {
                    const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                    tags.forEach(tag => postHashtags.add(tag));
                });
            }
            
            const allCandidateHashtags = [
                ...bioHashtags.map(h => h.toLowerCase().replace('#', '')),
                ...Array.from(postHashtags)
            ];
            
            const searchArray = Array.from(searchTags);
            const matches = searchArray.filter(tag => 
                allCandidateHashtags.some(ct => ct === tag.toLowerCase())
            );
            
            if (matchMode === 'all') {
                scores.hashtag = matches.length === searchArray.length ? 100 : 0;
            } else {
                scores.hashtag = Math.min(100, (matches.length / searchArray.length) * 100);
            }
        }

        let finalScore = 0;
        switch(discoveryMode) {
            case 'social':
                finalScore = scores.social * 0.7 + scores.interests * 0.2 + scores.engagement * 0.1;
                break;
            case 'interests':
                finalScore = scores.interests * 0.7 + scores.social * 0.2 + scores.niche * 0.1;
                break;
            case 'niche':
                finalScore = scores.niche * 0.7 + scores.interests * 0.2 + scores.social * 0.1;
                break;
            case 'hashtags':
                finalScore = scores.hashtag * 0.8 + scores.engagement * 0.15 + scores.social * 0.05;
                break;
        }

        // Stretch score range
finalScore = finalScore * 1.25;

// Convert to integer
let normalized = Math.round(finalScore);

// Apply realistic min/max values
if (normalized < 1) normalized = 1;
if (normalized > 100) normalized = 100;

return {
    total: normalized,
    breakdown: scores
};
    }

    // ========== SOCIAL GRAPH DISCOVERY FUNCTION ==========
async function getRecommendations(userPubkey, userFollows, limit, session) {
    if (session !== modeSessionId) return [];
    
console.log('User follows (locked snapshot):', userFollows.length);

    if (userFollows.length === 0) {
        console.log('No follows found, searching popular users...');
        
        try {
            // Check session again after async operation
            if (session !== modeSessionId) return [];
            
            if (userFollows.length === 0) {
  console.log('No follows found, using GLOBAL discovery sample...');

  if (session !== modeSessionId) return [];

  const resultCount = limit; // your getRecommendations param is already "limit"

  const globalCandidates = await getGlobalCandidates({
    relays: RELAYS,
    userPubkey,
    userFollows,
    resultCount,
    session,
    hoursBack: 72,
    eventLimit: 6000,
    minNotesPerUser: 2,
    excludeFollowed: true
  });

  if (session !== modeSessionId) return [];

  // If still empty, return your hardcoded fallback list as last resort
  if (globalCandidates.length === 0) {
    return [
      '82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2',
      '460c25e682fda7832b52d1f22d3d22b3176d972f60dcdc3212ed8c92ef85065c',
      '3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d',
      '85080d3bad70ccdcd7f74c29a44f55bb85cbcd3dd0cbb957da1d215bdb931204',
      'c48e29f04b482cc01ca1f9ef8c86ef8318c059e0e9353235162f080f26e14c11'
    ];
  }

  return globalCandidates;
}
            
            // Check session again
            if (session !== modeSessionId) return [];
            
            const userCounts = new Map();
            recentEvents.forEach(event => {
                const count = userCounts.get(event.pubkey) || 0;
                userCounts.set(event.pubkey, count + 1);
            });
            
            const topUsers = Array.from(userCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit * 5)
                .map(([pubkey]) => pubkey);
            
            console.log('Found', topUsers.length, 'popular users from last 90 days');
            
            // Final session check
            if (session !== modeSessionId) return [];
            
            // If still no users, return fallback users
            if (topUsers.length === 0) {
                console.log('No popular users found, using fallback users');
                return [
                    '82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2',
                    '460c25e682fda7832b52d1f22d3d22b3176d972f60dcdc3212ed8c92ef85065c',
                    '3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d',
                    '85080d3bad70ccdcd7f74c29a44f55bb85cbcd3dd0cbb957da1d215bdb931204',
                    'c48e29f04b482cc01ca1f9ef8c86ef8318c059e0e9353235162f080f26e14c11'
                ];
            }
            
            return topUsers;
        } catch (err) {
            console.error('Error finding popular users:', err);
            if (session !== modeSessionId) return [];
            
            return [
                '82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2',
                '460c25e682fda7832b52d1f22d3d22b3176d972f60dcdc3212ed8c92ef85065c',
                '3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d',
                '85080d3bad70ccdcd7f74c29a44f55bb85cbcd3dd0cbb957da1d215bdb931204',
                'c48e29f04b482cc01ca1f9ef8c86ef8318c059e0e9353235162f080f26e14c11'
            ];
        }
    }

    const candidates = new Set();
    const sampleSize = Math.min(30, userFollows.length);
    
    console.log('Sampling', sampleSize, 'of your', userFollows.length, 'follows');
    
    const shuffledFollows = [...userFollows]
        .sort(() => Math.random() - 0.5)
        .slice(0, sampleSize);
    
    const followsOfFollows = await fetchFollowsBatch(shuffledFollows);
    
    // Check session after async batch fetch
    if (session !== modeSessionId) return [];
    
    followsOfFollows.forEach(theirFollows => {
        theirFollows.forEach(pubkey => {
            if (pubkey !== userPubkey && !userFollows.includes(pubkey)) {
                candidates.add(pubkey);
            }
        });
    });

    const candidateArray = Array.from(candidates).sort(() => Math.random() - 0.5);
    console.log('Generated', candidateArray.length, 'total candidates');
    
    if (session !== modeSessionId) return [];
    return candidateArray.slice(0, limit * 4);
}

    function createProfileCard(fren) {
        const card = document.createElement('div');
        card.className = 'fren-card';
        
        if (fren.isFollowing) {
            card.classList.add('already-following');
        }
        
        const about = fren.about || '';
        const hashtags = (about.match(/#\w+/g) || []).slice(0, 3).map(t => t.substring(1));
        
        let metricsHTML = '<div class="metrics-container">';
        
        if (fren.crossRefCategory) {
            if (fren.crossRefCategory === 'mutual') {
                metricsHTML += `<span class="metric-badge high">Both Follow</span>`;
            } else if (fren.crossRefCategory === 'you-only') {
                metricsHTML += `<span class="metric-badge medium">You Follow</span>`;
            } else if (fren.crossRefCategory === 'them-only') {
                metricsHTML += `<span class="metric-badge medium">They Follow</span>`;
            }
        }
        
        if (fren.scores.breakdown.social > 40) {
            metricsHTML += `<span class="metric-badge high">${fren.mutual || 0} Mutual</span>`;
        }
        if (fren.scores.breakdown.interests > 40) {
            metricsHTML += `<span class="metric-badge medium">${hashtags.length} Tags</span>`;
        }
        
        const oneHourAgo = Math.floor(Date.now() / 1000) - 3600;
        const postedRecently = fren.notes?.some(note => note.created_at > oneHourAgo);
        if (postedRecently) {
            metricsHTML += `<span class="metric-badge high">Active</span>`;
        }
        
        metricsHTML += '</div>';
        
        const name = fren.name || 'Anonymous';
        const picture = fren.picture || `https://robohash.org/${fren.pubkey}?set=set5`;
        const bioText = about.substring(0, 150) + (about.length > 150 ? '...' : '');
        
        card.innerHTML = `
            <div class="fren-header">
                <img src="${picture}" 
                     class="fren-avatar" 
                     onerror="this.src='https://robohash.org/${fren.pubkey}?set=set5'">
                <div class="fren-info">
                    <div class="fren-name">${name}</div>
                    <div class="fren-npub" onclick="copyNpub('${fren.npub}')">${fren.npub.substring(0,20)}...</div>
                </div>
                <div class="match-score">${fren.scores.total}%</div>
            </div>
            <p class="fren-bio">${bioText}</p>
            ${metricsHTML}
            ${hashtags.length > 0 ? `
                <div class="tags-container">
                    ${hashtags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                </div>
            ` : ''}
            <div class="fren-actions">
                <button class="btn-follow ${fren.isFollowing ? 'following' : ''}" 
                        data-pubkey="${fren.pubkey}"
                        ${!currentUser ? 'disabled' : ''}>
                    ${fren.isFollowing ? 'Following' : 'Follow'}
                </button>
                <a href="https://njump.me/${fren.npub}" target="_blank" class="btn-view-profile">View</a>
            </div>
        `;

        const followBtn = card.querySelector('.btn-follow');
        followBtn.addEventListener('click', async () => {
            if (fren.isFollowing) return;
            followBtn.disabled = true;
            followBtn.textContent = 'Following...';
            const success = await followUser(fren.pubkey);
            if (success) {
                followBtn.textContent = 'Following';
                followBtn.classList.add('following');
                fren.isFollowing = true;
            } else {
                followBtn.disabled = false;
                followBtn.textContent = 'Follow';
            }
        });

        return card;
    }

    function renderResults(profiles) {
        const resultsGrid = document.getElementById('results-grid');
        resultsGrid.innerHTML = '';

        profiles.forEach(fren => {
            const card = createProfileCard(fren);
            resultsGrid.appendChild(card);
        });
    }

    // Main search
document.getElementById('find-btn').addEventListener('click', async () => {
    // NEW: Start a new search session
    modeSessionId++;
    const thisSession = modeSessionId;


    // LOCK CONTROLS
[
    '.mode-card',
    '#result-count',
    '#min-followers',
    '#activity-level',
    '#hide-spam',
    '#hide-nsfw',
    '#hide-following',
    '#recent-activity-only',
    '.toggle-switch',
    '#enable-cross-ref',
    '.cross-ref-toggle',
    '#hashtag-input',
    '.popular-tag',
    '#npub-input'
].forEach(sel => {
    document.querySelectorAll(sel).forEach(el => {
        el.style.pointerEvents = 'none';
        el.style.opacity = '0.6';
    });
});
    
    const findBtn = document.getElementById('find-btn');
    const resultsSection = document.getElementById('results-section');
    const emptyState = document.getElementById('empty-state');
    const resultsGrid = document.getElementById('results-grid');

    // SAFEGUARD: If we have a currentUser but their pubkey seems invalid
    if (currentUser && !currentUser.pubkey) {
        console.log('⚠️ Current user pubkey missing, forcing re-login');
        logout(); // Clear the broken state
        alert('Your login session was lost. Please login again.');
        return;
    }

        if (discoveryMode === 'hashtags') {
            if (selectedHashtags.size === 0) {
                alert('Please select at least one hashtag to search');
                return;
            }
        }

        let userPubkey;

        if (currentUser && currentUser.pubkey) {
            userPubkey = currentUser.pubkey;
        } else {
            const npubInput = document.getElementById('npub-input').value.trim();

            if (!npubInput) {
                alert('Please enter your npub or login');
                return;
            }

            if (!npubInput.startsWith('npub1')) {
                alert('Invalid npub format');
                return;
            }

            userPubkey = nip19.decode(npubInput).data;
        }

        if (findBtn.disabled) return;

        findBtn.disabled = true;
        findBtn.textContent = 'Discovering...';
        emptyState.style.display = 'none';
        resultsSection.style.display = 'block';
        resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';

        // FIX: Clear “People You Already Follow” immediately
const followingSection = document.getElementById('following-section');
const followingGrid = document.getElementById('following-grid');
followingSection.style.display = 'none';
followingGrid.innerHTML = '';

        try {
            const userProfile = await fetchProfile(userPubkey, thisSession);
if (!userProfile || !userProfile.pubkey) {
    console.warn('⚠️ User profile missing or stale — aborting search');
    return;
}

const userFollows = await fetchFollows(userPubkey);
await debugMyFollows(userPubkey);

            console.log('🔒 Using locked follow snapshot:', userFollows.length);

            let candidatePubkeys;
const resultCount = parseInt(document.getElementById('result-count').value);

if (discoveryMode === 'hashtags' && selectedHashtags.size > 0) {
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Searching posts for matching hashtags...</p>';
    candidatePubkeys = await searchUsersByHashtags(selectedHashtags, resultCount * 2, thisSession);
} else if (discoveryMode === 'interests') {
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Finding users with similar interests...</p>';
    candidatePubkeys = await discoverByInterests(
    userPubkey,
    userFollows,
    resultCount,
    thisSession
);
} else if (discoveryMode === 'niche') {
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Finding niche content creators...</p>';
    candidatePubkeys = await discoverByNiche(resultCount, thisSession);
} else if (crossRefEnabled && crossRefData) {
    const allCandidates = [
        ...crossRefData.youOnly,
        ...crossRefData.themOnly,
        ...crossRefData.mutual
    ];
    
    candidatePubkeys = Array.from(new Set(allCandidates))
        .slice(0, resultCount * 2);
    
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Comparing networks...</p>';
} else {
    // Social mode (default)
    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';
    candidatePubkeys = await getRecommendations(
    userPubkey,
    userFollows,
    resultCount,
    thisSession
);
}

            resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Fetching profiles and activity...</p>';

            console.log('Fetching data for', candidatePubkeys.length, 'candidates...');

// Fetch profiles and follows first
const [allProfiles, allFollows] = await Promise.all([
    fetchProfilesBatch(candidatePubkeys, thisSession),
    fetchFollowsBatch(candidatePubkeys)
]);

// ✅ NOW it is safe
const metaCount = allProfiles.filter(p => p && p.hasMetadata).length;
console.log(`Profiles with kind:0 metadata: ${metaCount}/${allProfiles.length}`);

// DEBUG: Log what we found
console.log('🔍 DEBUG: Fetched', allProfiles.length, 'profiles');
allProfiles.forEach((profile, idx) => {
    if (profile && profile.pubkey) {
        console.log(`  ${idx+1}. ${profile.name || 'Anonymous'} (${profile.pubkey.substring(0, 8)}...)`);
    }
});

// Use DEDICATED notes fetching based on mode
let allNotes;
if (discoveryMode === 'hashtags' || discoveryMode === 'niche') {
    // For hashtag-based modes: ALL-TIME notes (niche users might not post frequently)
    console.log(`Using ALL-TIME notes for ${discoveryMode} mode`);
    allNotes = await fetchNotesForHashtagModes(candidatePubkeys, 25);
} else {
    // For social-based modes: RECENT notes (30 days)
    console.log(`Using RECENT notes for ${discoveryMode} mode`);
    allNotes = await fetchNotesForSocialMode(candidatePubkeys, 25);
}

            const validProfiles = allProfiles.filter(p => p && p.pubkey).length;
            const withNotes = allNotes.filter(n => n && n.length > 0).length;
            const with3Plus = allNotes.filter(n => n && n.length >= 3).length;
            console.log(`Valid profiles: ${validProfiles}/${candidatePubkeys.length}`);
            console.log(`Profiles with notes: ${withNotes}, with 3+: ${with3Plus}`);

            // ================================
// 🔑 BUILD PUBKEY-LOCKED LOOKUPS
// ================================

// Profiles by pubkey
const profileByKey = new Map();
allProfiles.forEach(p => {
    if (p && p.pubkey) {
        profileByKey.set(p.pubkey, p);
    }
});

// Notes by pubkey (LOCKED to candidatePubkeys order)
const notesByKey = new Map();
candidatePubkeys.forEach((pk, i) => {
    notesByKey.set(pk, allNotes[i] || []);
});

// Follows by pubkey (LOCKED to candidatePubkeys order)
const followsByKey = new Map();
candidatePubkeys.forEach((pk, i) => {
    followsByKey.set(pk, allFollows[i] || []);
});

            resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Calculating match scores...</p>';

            const topicPopularity = new Map();
            allNotes.forEach((notes, idx) => {
                if (!notes) return;
                const profile = allProfiles[idx];
                if (!profile) return;
                
                const bioHashtags = (profile.about || '').match(/#\w+/gi) || [];
                bioHashtags.forEach(tag => {
                    const normalized = tag.toLowerCase().replace('#', '');
                    topicPopularity.set(normalized, (topicPopularity.get(normalized) || 0) + 1);
                });
                
                notes.forEach(note => {
                    const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                    tags.forEach(tag => {
                        topicPopularity.set(tag, (topicPopularity.get(tag) || 0) + 1);
                    });
                });
            });

            window.topicPopularity = topicPopularity;

const scoredProfiles = candidatePubkeys
  .map(pubkey => {
    const profile = profileByKey.get(pubkey);
    if (!profile || profile.pubkey !== pubkey) return null;

    const notes = notesByKey.get(pubkey) || [];
    const follows = followsByKey.get(pubkey) || [];

    const spamScore = detectSpam(profile, notes);
    const isNSFW = detectNSFW(profile, notes);

    const scores = calculateMatchScore(
      userProfile,
      profile,
      userFollows,
      follows,
      notes,
      discoveryMode === 'hashtags' ? selectedHashtags : null
    );

    const mutual = follows.filter(f => userFollows.includes(f)).length;

    let crossRefCategory = null;
    if (crossRefEnabled && crossRefData) {
      if (crossRefData.mutual.includes(profile.pubkey)) crossRefCategory = 'mutual';
      else if (crossRefData.youOnly.includes(profile.pubkey)) crossRefCategory = 'you-only';
      else if (crossRefData.themOnly.includes(profile.pubkey)) crossRefCategory = 'them-only';
    }

    return {
      ...profile,
      npub: nip19.npubEncode(profile.pubkey),
      scores,
      mutual,
      isFollowing: userFollowing.has(profile.pubkey),
      spamScore,
      isNSFW,
      crossRefCategory,
      notes,
      follows
    };
  })
  .map(p => {
    if (!p) return null;

    let penalty = 0;

        // ---- DELETED ACCOUNT DETECTION ----
const isDeleted = detectDeletedAccount(p, p.notes, p.follows);
if (isDeleted) {
    p.scores.total = 0; // force removal
    return null;        // hide completely
}

        // ---- NOTES REQUIREMENT ----
const noteCount = p.notes?.length || 0;
if (noteCount === 0) penalty += 40; // Heavily penalize no notes
if (noteCount === 1) penalty += 20; // Less penalty for 1 note
if (noteCount === 2) penalty += 10; // Even less for 2 notes

        // ---- HASHTAG MODE ----
        if (discoveryMode === 'hashtags' && p.scores.breakdown.hashtag === 0) {
            penalty += 40;
        }

        // ---- SPAM ----
        const hideSpam = document.getElementById('hide-spam').checked;
        if (hideSpam && p.spamScore > 60) penalty += 30;

        // ---- NSFW ----
        const hideNSFW = document.getElementById('hide-nsfw').checked;
        if (hideNSFW && p.isNSFW) penalty += 20;

        // ---- RECENT ACTIVITY ----
        const recentActivityOnly = document.getElementById('recent-activity-only').checked;
        if (recentActivityOnly) {
            const thirtyDaysAgo = Math.floor(Date.now() / 1000) - 30*24*60*60;
            const hasRecentNote = p.notes?.some(n => n.created_at > thirtyDaysAgo);
            if (!hasRecentNote) penalty += 40;
        }

        // ---- FOLLOWER MINIMUM ----
        const minFollowers = parseInt(document.getElementById('min-followers').value);
        const followCount = p.follows?.length || 0;
        if (minFollowers > 0 && followCount < minFollowers) {
            penalty += 30;
        }

        // ---- ACTIVITY LEVEL ----
        const activityLevel = document.getElementById('activity-level').value;
        const tenDaysAgo = Math.floor(Date.now() / 1000) - 10*24*60*60;
        const recentPosts = p.notes?.filter(n => n.created_at > tenDaysAgo).length || 0;

        if (activityLevel === 'high' && recentPosts < 5) penalty += 30;
        if (activityLevel === 'medium' && recentPosts < 2) penalty += 15;
        if (activityLevel === 'low' && recentPosts < 1) penalty += 10;

        // ---- APPLY PENALTY ----
        p.scores.total = p.scores.total - penalty;

// HARD remove only if score is extremely bad
if (p.scores.total < 1) return null; // or keep if you want to show 1%

        return p;
    })
    .filter(Boolean)
                .sort((a, b) => b.scores.total - a.scores.total)
                .slice(0, parseInt(document.getElementById('result-count').value));

            const hideFollowing = document.getElementById('hide-following').checked;
            
            let newProfiles, followingProfiles;
            
            if (hideFollowing) {
                newProfiles = scoredProfiles.filter(p => !p.isFollowing);
                followingProfiles = scoredProfiles.filter(p => p.isFollowing);
            } else {
                newProfiles = scoredProfiles;
                followingProfiles = [];
            }

            document.getElementById('results-count').textContent = `${newProfiles.length} matches`;

            if (newProfiles.length === 0 && followingProfiles.length > 0) {
                resultsGrid.innerHTML = `
                    <div style="text-align:center;padding:3rem;">
                        <h3 style="margin-bottom:1rem;">No New Discoveries</h3>
                        <p style="color:var(--text-secondary);">All ${followingProfiles.length} matches are people you already follow.</p>
                        <p style="color:var(--text-secondary);margin-top:0.5rem;">Try unchecking "Hide Already Following" or searching with different criteria.</p>
                    </div>
                `;
            } else if (newProfiles.length === 0) {
                resultsGrid.innerHTML = `
                    <div style="text-align:center;padding:3rem;">
                        <h3 style="margin-bottom:1rem;">No Matches Found</h3>
                        <p style="color:var(--text-secondary);">Try unchecking "Posted Within a Month" or adjusting other filters.</p>
                    </div>
                `;
            } else {
                renderResults(newProfiles);
            }

            const followingSection = document.getElementById('following-section');
            const followingGrid = document.getElementById('following-grid');

            if (followingProfiles.length > 0 && hideFollowing && newProfiles.length > 0) {
                followingSection.style.display = 'block';
                document.getElementById('following-count').textContent = followingProfiles.length;
                
                followingGrid.innerHTML = '';
                followingProfiles.forEach(fren => {
                    const card = createProfileCard(fren);
                    followingGrid.appendChild(card);
                });
            } else {
                followingSection.style.display = 'none';
                followingGrid.innerHTML = '';
            }
        } catch (err) {
            console.error('Error:', err);
            resultsGrid.innerHTML = `<p style="text-align:center;padding:2rem;color:var(--accent-primary)">Error: ${err.message}</p>`;
        } finally {
            findBtn.disabled = false;
            findBtn.textContent = 'Discover Frens';
            
            // UNLOCK CONTROLS
[
    '.mode-card',
    '#result-count',
    '#min-followers',
    '#activity-level',
    '#hide-spam',
    '#hide-nsfw',
    '#hide-following',
    '#recent-activity-only',
    '.toggle-switch',
    '#enable-cross-ref',
    '.cross-ref-toggle',
    '#hashtag-input',
    '.popular-tag',
    '#npub-input'
].forEach(sel => {
    document.querySelectorAll(sel).forEach(el => {
        el.style.pointerEvents = 'auto';
        el.style.opacity = '1';
    });
});
        }
    });

    document.getElementById('npub-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') document.getElementById('find-btn').click();
    });

    window.copyNpub = (npub) => {
        navigator.clipboard.writeText(npub).then(() => console.log('Copied:', npub));
    };

    document.getElementById('following-header').addEventListener('click', function() {
    const content = document.getElementById('following-content');
    const icon = document.getElementById('following-icon');

    if (getComputedStyle(content).display === 'none') {
        content.style.display = 'block';
        icon.textContent = '▼';
    } else {
        content.style.display = 'none';
        icon.textContent = '▶';
    }
});

    // Nsec modal event listeners
    document.getElementById('nsec-close').addEventListener('click', hideNsecModal);
    document.getElementById('nsec-cancel').addEventListener('click', hideNsecModal);
    document.getElementById('nsec-login').addEventListener('click', loginWithNsec);
    
    document.getElementById('nsec-input-field').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            loginWithNsec();
        }
    });
    
    document.getElementById('nsec-modal').addEventListener('click', function(e) {
        if (e.target === this) {
            hideNsecModal();
        }
    });

    updateUserUI();
});
</script>