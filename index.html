<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fren Finder - Advanced Nostr Discovery</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #faf8f5;
            --bg-secondary: #f0ede7;
            --bg-tertiary: #e8e3da;
            --text-primary: #1a1512;
            --text-secondary: #5a524a;
            --text-tertiary: #8a7f72;
            --accent-primary: #c84e3a;
            --accent-secondary: #2d5f4f;
            --accent-success: #2d7a4f;
            --accent-info: #3a6ea5;
            --border-color: #d4cec2;
            --shadow-color: rgba(26, 21, 18, 0.08);
            --transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1512;
            --bg-secondary: #2a2319;
            --bg-tertiary: #3a3229;
            --text-primary: #faf8f5;
            --text-secondary: #c4beb4;
            --text-tertiary: #8a7f72;
            --accent-primary: #e8745e;
            --accent-secondary: #4a9276;
            --accent-success: #4a9a70;
            --accent-info: #5a8ec5;
            --border-color: #3a3229;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            transition: var(--transition);
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        header {
            padding: 3rem 0 2rem;
            border-bottom: 1px solid var(--border-color);
            animation: fadeInDown 0.6s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .logo-section h1 {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: var(--transition);
            font-weight: 600;
            border: none;
        }

        .btn-login {
            background: var(--accent-primary);
            color: var(--bg-primary);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .btn-logout {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .theme-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .theme-toggle:hover, .btn-logout:hover {
            background: var(--bg-tertiary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        main {
            padding: 3rem 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .search-section {
            margin-bottom: 3rem;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }

        input[type="text"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .discovery-mode {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .mode-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
        }

        .mode-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .mode-card.active {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            box-shadow: 0 4px 16px var(--shadow-color);
        }

        .mode-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .mode-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        select {
            padding: 0.875rem 1.25rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition);
        }

        select:focus {
            outline: none;
            border-color: var(--accent-secondary);
        }

        .btn-primary {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 1rem;
        }

        .results-header h2 {
            font-size: 2rem;
            font-weight: 600;
        }

        .results-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .results-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .sort-dropdown {
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .fren-card {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 0.75rem;
    padding: 1.75rem;
    transition: var(--transition);
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

        .fren-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-primary);
            transform: scaleY(0);
            transition: var(--transition);
        }

        .fren-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .fren-card:hover::before {
            transform: scaleY(1);
        }

        .fren-card.already-following {
            opacity: 0.6;
            background: var(--bg-tertiary);
        }

        .fren-card.already-following:hover {
            opacity: 0.8;
        }

        .fren-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .fren-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
            flex-shrink: 0;
        }

        .fren-info {
            flex: 1;
            min-width: 0;
        }

        .fren-name {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .fren-npub {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: var(--transition);
            padding: 0.25rem;
            border-radius: 0.25rem;
        }

        .fren-npub:hover {
            color: var(--accent-primary);
        }

        .match-score {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            padding: 0.4rem 0.8rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .fren-bio {
            color: var(--text-secondary);
            margin-bottom: 1.25rem;
            font-size: 1rem;
            line-height: 1.6;
        }

        .metrics-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .metric-badge {
            background: var(--bg-tertiary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .metric-badge.high {
            background: var(--accent-success);
            color: var(--bg-primary);
            border-color: var(--accent-success);
        }

        .metric-badge.medium {
            background: var(--accent-info);
            color: var(--bg-primary);
            border-color: var(--accent-info);
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .tag {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
        }

        .fren-actions {
    display: flex;
    gap: 0.75rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border-color);
    margin-top: auto;
}

        .btn-follow {
            flex: 1;
            padding: 0.75rem;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .btn-follow:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-follow:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-follow.following {
            background: var(--accent-success);
        }

        .btn-view-profile {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            color: var(--text-primary);
            display: inline-block;
        }

        .btn-view-profile:hover {
            background: var(--bg-secondary);
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        footer {
            border-top: 1px solid var(--border-color);
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
            color: var(--text-tertiary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .toggle-group {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background-color: var(--bg-primary);
        }

        .toggle-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .already-following-section {
            margin-top: 3rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .following-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .following-header h3 {
            font-size: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .following-count {
            background: var(--accent-info);
            color: var(--bg-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .following-toggle-icon {
            font-size: 1.5rem;
            transition: var(--transition);
        }

        .following-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .following-content {
            display: none;
            padding-top: 1.5rem;
        }

        .following-content.visible {
            display: block;
        }

        .hashtag-search-container {
            display: none;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 0.75rem;
        }

        .hashtag-search-container.visible {
            display: block;
        }

        .hashtag-input-wrapper {
            position: relative;
            margin-bottom: 1rem;
        }

        .hashtag-input {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .hashtag-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .hashtag-input::placeholder {
            color: var(--text-tertiary);
        }

        .tag-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 10;
        }

        .tag-suggestions.visible {
            display: block;
        }

        .tag-suggestion-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }

        .tag-suggestion-item:hover {
            background: var(--bg-secondary);
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            min-height: 2.5rem;
        }

        .selected-tag {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2rem;
            line-height: 1;
        }

        .tag-remove:hover {
            transform: scale(1.2);
        }

        .match-mode-toggle {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .match-mode-btn {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            font-weight: 600;
        }

        .match-mode-btn.active {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .match-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .popular-tags {
            margin-top: 1rem;
        }

        .popular-tags-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .popular-tags-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .popular-tag {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .popular-tag:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .cross-reference-container {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .cross-ref-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cross-ref-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .cross-ref-toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
        }

        .cross-ref-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .cross-ref-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .cross-ref-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider {
            background-color: var(--accent-info);
            border-color: var(--accent-info);
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider:before {
            transform: translateX(18px);
            background-color: var(--bg-primary);
        }

        .cross-ref-input {
            width: 100%;
            padding: 0.875rem 1.25rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            transition: var(--transition);
            display: none;
        }

        .cross-ref-input.visible {
            display: block;
        }

        .cross-ref-input:focus {
            outline: none;
            border-color: var(--accent-info);
        }

        .comparison-results {
            margin-top: 2rem;
            display: none;
        }

        .comparison-results.visible {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .comparison-category {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .comparison-category h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            color: var(--accent-info);
        }

        .comparison-count {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .comparison-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .bunker-login-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            padding: 2rem;
            overflow-y: auto;
        }

        .bunker-login-modal.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bunker-login-content {
            background: var(--bg-primary);
            border: 2px solid var(--accent-info);
            border-radius: 0.75rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }

        .bunker-login-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }

        .bunker-login-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-info);
        }

        .bunker-close {
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .bunker-close:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .bunker-instructions {
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .bunker-instructions ol {
            text-align: left;
            padding-left: 1.5rem;
            margin-top: 1rem;
        }

        .bunker-instructions li {
            margin-bottom: 0.5rem;
        }

        .qr-code-container {
            background: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1.5rem auto;
            max-width: 300px;
        }

        .bunker-connection-string {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            word-break: break-all;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            max-height: 100px;
            overflow-y: auto;
        }

        .bunker-status {
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .bunker-status.waiting {
            color: var(--accent-info);
        }

        .bunker-status.connected {
            color: var(--accent-success);
        }

        .bunker-status.error {
            color: var(--accent-primary);
        }

        .btn-bunker {
            background: var(--accent-info);
            color: var(--bg-primary);
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 2rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(58, 110, 165, 0.2);
            transition: var(--transition);
        }

        .btn-bunker:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(58, 110, 165, 0.3);
        }

        .login-dropdown {
            position: relative;
        }

        .login-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            box-shadow: 0 8px 24px var(--shadow-color);
            z-index: 100;
            min-width: 200px;
        }

        .login-menu.visible {
            display: block;
        }

        .login-option {
            padding: 0.875rem 1.25rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
        }

        .login-option:last-child {
            border-bottom: none;
        }

        .login-option:hover {
            background: var(--bg-secondary);
        }

        @media (max-width: 768px) {
            .logo-section h1 { font-size: 2.5rem; }
            .header-content { flex-direction: column; }
            .filter-row { grid-template-columns: 1fr; }
            .results-grid { grid-template-columns: 1fr; }
            .discovery-mode { grid-template-columns: 1fr; }
            .toggle-group { flex-direction: column; gap: 1rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="logo-section">
                    <h1>Fren Finder</h1>
                    <p class="subtitle">Advanced Nostr Discovery</p>
                </div>
                <div class="header-actions">
                    <div id="user-section"></div>
                    <button class="btn theme-toggle" id="theme-btn">Toggle Theme</button>
                </div>
            </div>
        </header>

        <main>
            <section class="search-section">
                <div class="input-group">
                    <label for="npub-input">Your Nostr Public Key</label>
                    <input type="text" id="npub-input" placeholder="npub1... (or click Login)">
                </div>

                <div class="cross-reference-container">
                    <div class="cross-ref-toggle">
                        <label class="cross-ref-toggle-switch">
                            <input type="checkbox" id="enable-cross-ref">
                            <span class="cross-ref-toggle-slider"></span>
                        </label>
                        <div class="cross-ref-label">
                            Cross-Reference With Another Account
                        </div>
                    </div>
                    <input type="text" 
                           class="cross-ref-input" 
                           id="cross-ref-input" 
                           placeholder="Enter another npub to compare networks">
                    
                    <div class="comparison-results" id="comparison-results">
                        <div class="comparison-category">
                            <h4>You Follow</h4>
                            <div class="comparison-count" id="you-only-count">0</div>
                            <div class="comparison-desc">Accounts only you follow</div>
                        </div>
                        <div class="comparison-category">
                            <h4>Both Follow</h4>
                            <div class="comparison-count" id="mutual-count">0</div>
                            <div class="comparison-desc">Shared connections</div>
                        </div>
                        <div class="comparison-category">
                            <h4>They Follow</h4>
                            <div class="comparison-count" id="them-only-count">0</div>
                            <div class="comparison-desc">Accounts only they follow</div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Discovery Mode</label>
                    <div class="discovery-mode">
                        <div class="mode-card active" data-mode="social">
                            <div class="mode-title">Social Graph</div>
                            <div class="mode-desc">Friends of friends</div>
                        </div>
                        <div class="mode-card" data-mode="interests">
                            <div class="mode-title">Shared Interests</div>
                            <div class="mode-desc">Hashtag matching</div>
                        </div>
                        <div class="mode-card" data-mode="niche">
                            <div class="mode-title">Niche Communities</div>
                            <div class="mode-desc">Specific topics</div>
                        </div>
                        <div class="mode-card" data-mode="hashtags">
                            <div class="mode-title">Hashtag Discovery</div>
                            <div class="mode-desc">Search by tags</div>
                        </div>
                    </div>
                </div>

                <div class="hashtag-search-container" id="hashtag-search">
                    <div class="hashtag-input-wrapper">
                        <input type="text" 
                               class="hashtag-input" 
                               id="hashtag-input" 
                               placeholder="Enter hashtags (e.g., bitcoin, nostr, photography)">
                        <div class="tag-suggestions" id="tag-suggestions"></div>
                    </div>

                    <div class="selected-tags" id="selected-tags"></div>

                    <div class="match-mode-toggle">
                        <button class="match-mode-btn active" id="match-any">Match ANY Tag</button>
                        <button class="match-mode-btn" id="match-all">Match ALL Tags</button>
                    </div>

                    <div class="popular-tags">
                        <div class="popular-tags-label">Popular Tags</div>
                        <div class="popular-tags-grid" id="popular-tags"></div>
                    </div>
                </div>

                <div class="toggle-group">
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-spam" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide Spam</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-nsfw" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide NSFW</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="hide-following" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Hide Already Following</span>
    </div>
    <div class="toggle-item">
        <label class="toggle-switch">
            <input type="checkbox" id="recent-activity-only" checked>
            <span class="toggle-slider"></span>
        </label>
        <span class="toggle-label">Posted Within a Month</span>
    </div>
</div>

                <div class="filter-row">
                    <div class="input-group">
                        <label for="min-followers">Min Network Size</label>
                        <select id="min-followers">
                            <option value="0">Any Size</option>
                            <option value="10">Small (10+)</option>
                            <option value="50">Medium (50+)</option>
                            <option value="100">Large (100+)</option>
                            <option value="500">Very Large (500+)</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="activity-level">Activity Level</label>
                        <select id="activity-level">
                            <option value="any">Any Activity</option>
                            <option value="high">Very Active</option>
                            <option value="medium">Moderately Active</option>
                            <option value="low">Occasional</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="result-count">Results</label>
                        <select id="result-count">
                            <option value="10">10 Profiles</option>
                            <option value="25">25 Profiles</option>
                            <option value="50">50 Profiles</option>
                        </select>
                    </div>
                </div>

                <button class="btn-primary" id="find-btn">Discover Frens</button>
            </section>

            <div class="bunker-login-modal" id="bunker-login-modal">
                <div class="bunker-login-content">
                    <div class="bunker-login-header">
                        <h3>Remote Signer Login</h3>
                        <span class="bunker-close" id="close-bunker">×</span>
                    </div>
                    <div class="bunker-instructions">
                        <p><strong>Instructions for Remote Signing:</strong></p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>For Amber (Android):</strong><br>
                            1. Open Amber app<br>
                            2. Tap "Connect Application"<br>
                            3. Scan QR code or paste connection string<br>
                            4. Approve the connection
                        </p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>For Nsec.app:</strong><br>
                            1. Go to nsec.app on mobile<br>
                            2. Tap "Connect"<br>
                            3. Scan QR code<br>
                            4. Approve permissions
                        </p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>Manual Setup:</strong><br>
                            Copy the connection string below and paste into your signing app
                        </p>
                    </div>
                    <div class="qr-code-container" id="qr-code-container"></div>
                    <div class="bunker-connection-string" id="bunker-connection-string"></div>
                    <button class="btn-primary" id="copy-connection-btn" style="margin-top: 1rem; display: none;">
                        Copy Connection String
                    </button>
                    <div class="bunker-status waiting" id="bunker-status">Waiting for connection...</div>
                </div>
            </div>

            <section class="results-section" id="results-section">
                <div class="results-header">
    <h2>Discovered Frens</h2>
    <div class="results-info">
        <span class="results-count" id="results-count">0 matches</span>
    </div>
</div>
                <div class="results-grid" id="results-grid"></div>

                <div class="already-following-section" id="following-section" style="display: none;">
                    <div class="following-header" id="following-header">
                        <h3>People You Already Follow</h3>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span class="following-count" id="following-count">0</span>
                            <span class="following-toggle-icon" id="following-icon">▼</span>
                        </div>
                    </div>
                    <div class="following-content" id="following-content">
                        <div class="results-grid" id="following-grid"></div>
                    </div>
                </div>
            </section>

            <section id="empty-state" class="empty-state">
                <h3>Discover Your Frens</h3>
                <p>Choose a discovery mode and find people based on multiple matching signals</p>
            </section>
        </main>

        <footer>
            <p>Fren Finder - Advanced Discovery for Nostr</p>
        </footer>
    </div>

   <script type="module">
  import * as NostrTools from "https://esm.sh/nostr-tools@2.7.2";
  import * as nip46 from "https://esm.sh/nostr-tools@2.7.2/nip46";

  window.NostrTools = { ...NostrTools, nip46 };
</script>
<script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>

<script type="module">
  import * as NostrTools from "https://esm.sh/nostr-tools@2.7.2";
  import * as nip46 from "https://esm.sh/nostr-tools@2.7.2/nip46";

  window.NostrTools = { ...NostrTools, nip46 };
</script>
<script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>

<script>
const profileCache = new Map();  
const noteCache = new Map();
let currentUser = null;
let userFollowing = new Set();
let discoveryMode = 'social';
let bunkerConnection = null;
let bunkerLoginInProgress = false;
let bunkerCapabilities = null;

window.addEventListener('load', async function() {
    if (typeof NostrTools === 'undefined') {
        alert('Failed to load Nostr tools');
        return;
    }

    const { nip19, SimplePool } = NostrTools;
    const pool = new SimplePool();
    window._nostrPool = pool;
    
    const RELAYS = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://relay.nsec.app'];

    // Theme toggle
    document.getElementById('theme-btn').addEventListener('click', () => {
        const html = document.documentElement;
        const theme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
        html.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
    });
    document.documentElement.setAttribute('data-theme', localStorage.getItem('theme') || 'light');

    // Spam detection
    function detectSpam(profile, notes) {
        let spamScore = 0;
        const name = (profile.name || '').toLowerCase();
        const about = (profile.about || '').toLowerCase();
        
        const spamPhrases = ['hello world', 'test test', 'testing 123', 'this is a test', 'hello nostr', 'first post', 'new here'];
        
        for (const phrase of spamPhrases) {
            if (about.includes(phrase) && about.length < 50) spamScore += 30;
        }
        
        if (about.length === 0) spamScore += 20;
        if (about.length > 0 && about.length < 10) spamScore += 15;
        if (name.match(/^user\d+$/i)) spamScore += 25;
        if (name.match(/^anon\d+$/i)) spamScore += 20;
        if (name === 'anon' || name === '') spamScore += 10;
        if (!profile.picture) spamScore += 10;
        if (notes && notes.length === 0) spamScore += 20;
        if (notes && notes.length === 1) spamScore += 10;
        
        if (notes && notes.length > 1) {
            const contents = notes.map(n => n.content.toLowerCase());
            const uniqueContents = new Set(contents);
            if (uniqueContents.size < notes.length / 2) spamScore += 15;
        }
        
        return spamScore;
    }

    // NSFW detection
    function detectNSFW(profile) {
        const about = (profile.about || '').toLowerCase();
        const name = (profile.name || '').toLowerCase();
        const nsfwTags = ['#nsfw', '#xxx', '#adult', '#18+', '#porn', '#onlyfans', 'nsfw', '18+'];
        
        for (const tag of nsfwTags) {
            if (about.includes(tag) || name.includes(tag)) return true;
        }
        return false;
    }

    // Discovery mode selection
    document.querySelectorAll('.mode-card').forEach(card => {
        card.addEventListener('click', function() {
            document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('active'));
            this.classList.add('active');
            discoveryMode = this.dataset.mode;
            
            const hashtagSearch = document.getElementById('hashtag-search');
            if (discoveryMode === 'hashtags') {
                hashtagSearch.classList.add('visible');
            } else {
                hashtagSearch.classList.remove('visible');
            }
        });
    });

    // Hashtag setup
    const selectedHashtags = new Set();
    let matchMode = 'any';

    const POPULAR_TAGS = ['bitcoin', 'nostr', 'lightning', 'crypto', 'privacy', 'art', 'photography', 'music', 'writing', 'design', 'coding', 'tech', 'ai', 'web3', 'freedom', 'travel', 'food', 'fitness', 'nature', 'coffee', 'startup', 'business', 'marketing', 'trading', 'investing'];

    function renderPopularTags() {
        const container = document.getElementById('popular-tags');
        container.innerHTML = '';
        POPULAR_TAGS.forEach(tag => {
            const tagEl = document.createElement('div');
            tagEl.className = 'popular-tag';
            tagEl.textContent = `#${tag}`;
            tagEl.addEventListener('click', () => addHashtag(tag));
            container.appendChild(tagEl);
        });
    }
    renderPopularTags();

    document.getElementById('match-any').addEventListener('click', function() {
        matchMode = 'any';
        document.querySelectorAll('.match-mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
    });

    document.getElementById('match-all').addEventListener('click', function() {
        matchMode = 'all';
        document.querySelectorAll('.match-mode-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
    });

    function addHashtag(tag) {
        const normalized = tag.toLowerCase().replace(/^#/, '');
        if (!selectedHashtags.has(normalized)) {
            selectedHashtags.add(normalized);
            renderSelectedTags();
        }
        document.getElementById('hashtag-input').value = '';
        document.getElementById('tag-suggestions').classList.remove('visible');
    }

    document.getElementById('hashtag-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            const tag = e.target.value.trim();
            if (tag) addHashtag(tag);
        }
    });

    function removeHashtag(tag) {
        selectedHashtags.delete(tag);
        renderSelectedTags();
    }

    function renderSelectedTags() {
        const container = document.getElementById('selected-tags');
        container.innerHTML = '';
        
        if (selectedHashtags.size === 0) {
            container.innerHTML = '<div style="color: var(--text-tertiary); font-style: italic;">No tags selected</div>';
            return;
        }

        selectedHashtags.forEach(tag => {
            const tagEl = document.createElement('div');
            tagEl.className = 'selected-tag';
            tagEl.innerHTML = `#${tag}<span class="tag-remove" onclick="removeHashtag('${tag}')">×</span>`;
            container.appendChild(tagEl);
        });
    }
    renderSelectedTags();

    window.removeHashtag = removeHashtag;

    // Cross-reference
    let crossRefEnabled = false;
    let crossRefData = null;

    document.getElementById('enable-cross-ref').addEventListener('change', function() {
        crossRefEnabled = this.checked;
        const crossRefInput = document.getElementById('cross-ref-input');
        const comparisonResults = document.getElementById('comparison-results');
        
        if (crossRefEnabled) {
            crossRefInput.classList.add('visible');
        } else {
            crossRefInput.classList.remove('visible');
            comparisonResults.classList.remove('visible');
            crossRefData = null;
        }
    });

    document.getElementById('cross-ref-input').addEventListener('blur', async function() {
        const crossRefNpub = this.value.trim();
        
        if (!crossRefNpub || !crossRefNpub.startsWith('npub1')) return;

        const mainNpub = document.getElementById('npub-input').value.trim();
        if (!mainNpub || !mainNpub.startsWith('npub1')) {
            alert('Please enter your main npub first');
            return;
        }

        try {
            const { data: mainPubkey } = nip19.decode(mainNpub);
            const { data: crossPubkey } = nip19.decode(crossRefNpub);

            const mainFollows = await fetchFollows(mainPubkey);
            const crossFollows = await fetchFollows(crossPubkey);

            const mainSet = new Set(mainFollows);
            const crossSet = new Set(crossFollows);

            const youOnly = mainFollows.filter(p => !crossSet.has(p));
            const themOnly = crossFollows.filter(p => !mainSet.has(p));
            const mutual = mainFollows.filter(p => crossSet.has(p));

            crossRefData = { youOnly, themOnly, mutual };

            document.getElementById('you-only-count').textContent = youOnly.length;
            document.getElementById('mutual-count').textContent = mutual.length;
            document.getElementById('them-only-count').textContent = themOnly.length;
            document.getElementById('comparison-results').classList.add('visible');
        } catch (err) {
            console.error('Cross-reference error:', err);
            alert('Failed to analyze cross-reference');
        }
    });

    // Login functions
    async function checkExtension() {
        return typeof window.nostr !== 'undefined';
    }

    async function loginWithExtension() {
        if (typeof window.nostr === 'undefined') {
            alert('Please install a Nostr browser extension (Alby, nos2x)');
            return null;
        }

        try {
            const pubkey = await window.nostr.getPublicKey();
            const npub = nip19.npubEncode(pubkey);
            const profile = await fetchProfile(pubkey);
            currentUser = { pubkey, npub, profile };
            const follows = await fetchFollows(pubkey);
            userFollowing = new Set(follows);
            updateUserUI();
            document.getElementById('npub-input').value = npub;
            document.getElementById('npub-input').disabled = true;
            return npub;
        } catch (err) {
            console.error('Login error:', err);
            alert('Failed to login');
            return null;
        }
    }

    function logout() {
    currentUser = null;
    userFollowing.clear();
    bunkerConnection = null;
    bunkerCapabilities = null;

    if (window._bunkerSub) {
        window._bunkerSub.close();
        window._bunkerSub = null;
    }
    if (window._bunkerHeartbeat) {
        clearInterval(window._bunkerHeartbeat);
        window._bunkerHeartbeat = null;
    }
    
    document.getElementById('npub-input').value = '';
    document.getElementById('npub-input').disabled = false;
    updateUserUI();
}

    function updateUserUI() {
        const userSection = document.getElementById('user-section');
        const npubInput = document.getElementById('npub-input');

        if (currentUser) {
            if (currentUser.npub) {
                npubInput.value = currentUser.npub;
                npubInput.disabled = true;
            }

            const name = currentUser.profile?.name || 'Anon';
            const picture = currentUser.profile?.picture || `https://robohash.org/${currentUser.pubkey}?set=set5`;
            
            userSection.innerHTML = `
                <div class="user-info">
                    <img src="${picture}" class="user-avatar" onerror="this.src='https://robohash.org/${currentUser.pubkey}?set=set5'">
                    <span>${name}</span>
                </div>
                <button class="btn btn-logout" id="logout-btn">Logout</button>
            `;
            document.getElementById('logout-btn').addEventListener('click', logout);
        } else {
            npubInput.value = '';
            npubInput.disabled = false;

            userSection.innerHTML = `
                <div class="login-dropdown">
                    <button class="btn btn-login" id="login-btn">Login</button>
                    <div class="login-menu" id="login-menu">
                        <div class="login-option" id="extension-login">Extension Login</div>
                        <div class="login-option" id="bunker-login-option">Remote Signer</div>
                    </div>
                </div>
            `;
            
            const loginBtn = document.getElementById('login-btn');
            const loginMenu = document.getElementById('login-menu');
            
            loginBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                loginMenu.classList.toggle('visible');
            });
            
            document.getElementById('extension-login').addEventListener('click', function() {
                loginMenu.classList.remove('visible');
                loginWithExtension();
            });
            
            document.getElementById('bunker-login-option').addEventListener('click', function() {
                loginMenu.classList.remove('visible');
                showBunkerLogin();
            });
            
            document.addEventListener('click', function() {
                loginMenu.classList.remove('visible');
            });
        }
    }

    function getClientSecretKeyBytes() {
    // Generate a fresh secret every time for security
    const sk = NostrTools.generateSecretKey();
    const hex = Array.from(sk).map(b => b.toString(16).padStart(2, '0')).join('');
    return new Uint8Array(hex.match(/.{2}/g).map(b => parseInt(b, 16)));
}

    function makeNostrConnectSecret() {
        const bytes = crypto.getRandomValues(new Uint8Array(32));
        return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

async function showBunkerLogin() {
    // Prevent multiple simultaneous login attempts
    if (bunkerLoginInProgress) {
        console.log('Bunker login already in progress');
        return;
    }
    
    bunkerLoginInProgress = true;
    
    const modal = document.getElementById('bunker-login-modal');
    const statusEl = document.getElementById('bunker-status');
    const qrContainer = document.getElementById('qr-code-container');
    const connectionStringEl = document.getElementById('bunker-connection-string');

    console.log('=== SHOW BUNKER LOGIN CALLED ===');

    qrContainer.innerHTML = '';
    connectionStringEl.textContent = '';

    const bunkerClientSecret = getClientSecretKeyBytes();
    const clientPubkey = NostrTools.getPublicKey(bunkerClientSecret);

    console.log('=== NEW BUNKER CONNECTION ===');
    console.log('Client pubkey:', clientPubkey);
    console.log('Client secret length:', bunkerClientSecret.length);

    const relays = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://relay.nsec.app'];
    const secret = makeNostrConnectSecret();

    const params = new URLSearchParams();
    relays.forEach(r => params.append('relay', r));
    params.append('secret', secret);
    params.append('name', 'Fren Finder');

    const connectionString = `nostrconnect://${clientPubkey}?${params.toString()}`;
    connectionStringEl.textContent = connectionString;

    console.log('Connection string:', connectionString);

    // Render QR
    try {
        if (typeof qrcode !== 'undefined') {
            const qr = qrcode(0, 'L');
            qr.addData(connectionString);
            qr.make();

            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 200;
            const ctx = canvas.getContext('2d');
            const cellSize = 200 / qr.getModuleCount();

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 200, 200);

            ctx.fillStyle = '#000000';
            for (let row = 0; row < qr.getModuleCount(); row++) {
                for (let col = 0; col < qr.getModuleCount(); col++) {
                    if (qr.isDark(row, col)) {
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }

            qrContainer.appendChild(canvas);
            console.log('QR code rendered');
        } else {
            console.error('qrcode library not loaded');
        }
    } catch (err) {
        console.error('QR error:', err);
    }

    modal.classList.add('visible');
    statusEl.className = 'bunker-status waiting';
    statusEl.textContent = 'Scan with your signer app...';

    const copyBtn = document.getElementById('copy-connection-btn');
    copyBtn.style.display = 'block';
    copyBtn.textContent = 'Copy Connection String';
    copyBtn.onclick = () => {
        navigator.clipboard.writeText(connectionString).then(() => {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => (copyBtn.textContent = 'Copy Connection String'), 2000);
        });
    };

    console.log('About to call listenForBunkerConnection...');
    listenForBunkerConnection(relays, clientPubkey, bunkerClientSecret, statusEl);
    console.log('listenForBunkerConnection called');
}

    function listenForBunkerConnection(relays, clientPubkey, clientSecret, statusEl) {
    console.log('=== listenForBunkerConnection CALLED ===');
    console.log('Client pubkey:', clientPubkey);
    
    // Track if we've requested the public key
    let publicKeyRequested = false;
    
    const sub = pool.subscribeMany(relays, [
        {
            kinds: [24133],
            '#p': [clientPubkey],
            since: Math.floor(Date.now() / 1000) - 60
        }
    ], {
        async onevent(event) {
            console.log('=== RECEIVED NIP-46 EVENT ===');
            console.log('Event from:', event.pubkey);
            
            try {
                const remotePubkey = String(event.pubkey);
                const content = String(event.content);
                
                let decrypted;
                
                try {
                    if (NostrTools.nip44) {
                        const conversationKey = NostrTools.nip44.getConversationKey(
                            clientSecret, 
                            remotePubkey
                        );
                        decrypted = NostrTools.nip44.decrypt(content, conversationKey);
                    } else {
                        throw new Error('nip44 not available');
                    }
                } catch (e1) {
                    const secretKeyHex = Array.from(clientSecret)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    decrypted = await NostrTools.nip04.decrypt(secretKeyHex, remotePubkey, content);
                }
                
                console.log('Decrypted message:', decrypted);
                
                // Inside listenForBunkerConnection's onevent handler:
const message = JSON.parse(decrypted);
console.log('Message:', message);

// Handle capabilities response
if (message.result && Array.isArray(message.result)) {
    console.log('=== RECEIVED CAPABILITIES ===');
    console.log('Capabilities:', message.result);
    bunkerCapabilities = new Set(message.result);
    return; // Don't process further
}
                
                // Handle connection acknowledgment
                if ((message.result === 'ack' || message.method === 'connect') && !publicKeyRequested) {
                    console.log('=== GOT CONNECTION ACK - REQUESTING PUBKEY ===');
                    
                    statusEl.className = 'bunker-status connected';
                    statusEl.textContent = 'Connected! Getting your public key...';
                    
                    publicKeyRequested = true;
                    await requestPublicKey(remotePubkey, clientSecret);
                    return;
                }
                
                // Handle responses with 64-char string results
                if (message.result && typeof message.result === 'string' && message.result.length === 64) {
                    console.log('Got 64-char string:', message.result);
                    
                    // If we've requested the public key, this should be it
                    // Otherwise it's probably the connection secret being echoed back
                    if (publicKeyRequested) {
                        console.log('=== THIS IS THE PUBLIC KEY ===');
                        await completeBunkerLogin(message.result, remotePubkey, clientSecret);
                    } else {
                        console.log('=== IGNORING - CONNECTION SECRET, NOT PUBKEY ===');
                        // This is the first response with the connection secret
                        // Now request the actual public key
                        console.log('First contact - requesting public key...');
                        
                        statusEl.className = 'bunker-status connected';
                        statusEl.textContent = 'Connected! Getting your public key...';
                        
                        publicKeyRequested = true;
                        await requestPublicKey(remotePubkey, clientSecret);
                    }
                }
                
            } catch (err) {
                console.error('=== ERROR ===');
                console.error(err);
                statusEl.className = 'bunker-status error';
                statusEl.textContent = 'Error: ' + err.message;
            }
        },
        oneose() {
            console.log('=== SUBSCRIPTION EOSE ===');
        }
    });
    
    window._bunkerSub = sub;
}

    async function requestPublicKey(remotePubkey, clientSecret) {
        console.log('Requesting public key from:', remotePubkey);
        
        const requestId = crypto.randomUUID();
        const request = {
            id: requestId,
            method: 'get_public_key',
            params: []
        };
        
        console.log('Request:', request);
        
        // Use nip44 for encryption
        let encrypted;
        try {
            if (NostrTools.nip44) {
                const conversationKey = NostrTools.nip44.getConversationKey(clientSecret, remotePubkey);
                encrypted = NostrTools.nip44.encrypt(JSON.stringify(request), conversationKey);
            } else {
                const secretKeyHex = Array.from(clientSecret)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
                encrypted = await NostrTools.nip04.encrypt(secretKeyHex, remotePubkey, JSON.stringify(request));
            }
        } catch (err) {
            console.error('Encryption error:', err);
            throw err;
        }
        
        const unsignedEvent = {
            kind: 24133,
            created_at: Math.floor(Date.now() / 1000),
            tags: [['p', remotePubkey]],
            content: encrypted,
            pubkey: NostrTools.getPublicKey(clientSecret)
        };
        
        const event = NostrTools.finalizeEvent(unsignedEvent, clientSecret);
        
        console.log('Sending get_public_key request, ID:', requestId);
        
        const relays = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://relay.nsec.app'];
        await Promise.all(relays.map(relay => pool.publish([relay], event)));
        
        return requestId;
    }

   async function completeBunkerLogin(userPubkey, remotePubkey, clientSecret) {
    try {
        const statusEl = document.getElementById('bunker-status');

        console.log('=== COMPLETING BUNKER LOGIN ===');
        console.log('User pubkey:', userPubkey);

        statusEl.className = 'bunker-status connected';
        statusEl.textContent = 'Loading your profile...';

        const npub = nip19.npubEncode(userPubkey);
        console.log('Encoded npub:', npub);
        
        const profile = await fetchProfile(userPubkey);
        console.log('Fetched profile:', profile);

        statusEl.textContent = 'Loading your follows...';
        const follows = await fetchFollows(userPubkey);
        console.log('Follows count:', follows.length);

        currentUser = { pubkey: userPubkey, npub, profile, bunker: true };
        userFollowing = new Set(follows);
        bunkerConnection = { remotePubkey, clientSecret };

        // ===== ADD THIS SECTION HERE =====
        // Close the login subscription since we're done with it
        if (window._bunkerSub) {
            console.log('Closing login subscription...');
            window._bunkerSub.close();
            window._bunkerSub = null;
        }

        // Request capabilities but don't wait - we'll assume signing works
        requestSignerCapabilities(
            bunkerConnection.remotePubkey,
            bunkerConnection.clientSecret
        ).catch(err => console.warn('Could not request capabilities:', err));

        // Set default capabilities immediately (assume all available)
        if (!bunkerCapabilities) {
            bunkerCapabilities = new Set(['sign_event', 'ping', 'get_public_key', 'get_capabilities']);
        }
        // ===== END NEW SECTION =====

        console.log('currentUser set to:', currentUser);
        updateUserUI();

        statusEl.textContent = 'Login successful!';

        // Start heartbeat monitoring
        const relays = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://relay.nsec.app'];

        let consecutiveFailures = 0;
        const maxFailures = 3;

        const heartbeatInterval = setInterval(async () => {
            if (!bunkerConnection || !bunkerConnection.remotePubkey) {
                console.warn('Bunker connection lost, stopping heartbeat');
                clearInterval(heartbeatInterval);
                return;
            }

            try {
                console.log('Sending heartbeat ping...');
                
                const pingRequest = {
                    id: crypto.randomUUID(),
                    method: 'ping',
                    params: []
                };
                
                let encrypted;
                if (NostrTools.nip44) {
                    const conversationKey = NostrTools.nip44.getConversationKey(
                        bunkerConnection.clientSecret, 
                        bunkerConnection.remotePubkey
                    );
                    encrypted = NostrTools.nip44.encrypt(JSON.stringify(pingRequest), conversationKey);
                } else {
                    const secretKeyHex = Array.from(bunkerConnection.clientSecret)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    encrypted = await NostrTools.nip04.encrypt(
                        secretKeyHex, 
                        bunkerConnection.remotePubkey, 
                        JSON.stringify(pingRequest)
                    );
                }
                
                const unsignedEvent = {
                    kind: 24133,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['p', bunkerConnection.remotePubkey]],
                    content: encrypted,
                    pubkey: NostrTools.getPublicKey(bunkerConnection.clientSecret)
                };
                
                const event = NostrTools.finalizeEvent(unsignedEvent, bunkerConnection.clientSecret);
                
                await Promise.all(relays.map(relay => pool.publish([relay], event)));
                
                const pongReceived = await new Promise((resolve) => {
                    const timeout = setTimeout(() => resolve(false), 10000);
                    
                    const sub = pool.subscribeMany(relays, [
                        {
                            kinds: [24133],
                            '#p': [event.pubkey],
                            since: Math.floor(Date.now() / 1000) - 5
                        }
                    ], {

                        async onevent(responseEvent) {
                            try {
                                let decrypted;
                                if (NostrTools.nip44) {
                                    const conversationKey = NostrTools.nip44.getConversationKey(
                                        bunkerConnection.clientSecret, 
                                        responseEvent.pubkey
                                    );
                                    decrypted = NostrTools.nip44.decrypt(responseEvent.content, conversationKey);
                                } else {
                                    const secretKeyHex = Array.from(bunkerConnection.clientSecret)
                                        .map(b => b.toString(16).padStart(2, '0'))
                                        .join('');
                                    decrypted = await NostrTools.nip04.decrypt(
                                        secretKeyHex, 
                                        responseEvent.pubkey, 
                                        responseEvent.content
                                    );
                                }
                                
                                const response = JSON.parse(decrypted);
                                
                                if (response.id === pingRequest.id) {
                                    clearTimeout(timeout);
                                    sub.close();
                                    resolve(true);
                                }
                            } catch (err) {
                                // Ignore
                            }
                        }
                    });
                });
                
                if (pongReceived) {
                    console.log('Heartbeat pong received');
                    consecutiveFailures = 0;
                } else {
                    console.warn('Heartbeat ping failed');
                    consecutiveFailures++;
                    
                    if (consecutiveFailures >= maxFailures) {
                        console.error('Remote signer not responding. Logging out...');
                        clearInterval(heartbeatInterval);
                        alert('Remote signer connection lost. Logging out...');
                        logout();
                    }
                }
                
            } catch (err) {
                console.error('Heartbeat error:', err);
                consecutiveFailures++;
                
                if (consecutiveFailures >= maxFailures) {
                    console.error('Remote signer not responding. Logging out...');
                    clearInterval(heartbeatInterval);
                    alert('Remote signer connection lost. Logging out...');
                    logout();
                }
            }
        }, 60000); // Every 60 seconds

        window._bunkerHeartbeat = heartbeatInterval;

        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const modal = document.getElementById('bunker-login-modal');
        modal.classList.remove('visible');

        bunkerLoginInProgress = false;

        console.log('Modal closed, login complete');
    } catch (err) {
        console.error('Complete login error:', err);
        const statusEl = document.getElementById('bunker-status');
        statusEl.className = 'bunker-status error';
        statusEl.textContent = 'Login failed: ' + err.message;
        
        bunkerLoginInProgress = false;
    }
}

    async function signEventWithBunker(event) {
    if (!bunkerConnection || !bunkerConnection.remotePubkey) {
        throw new Error('Bunker not connected');
    }

    if (bunkerCapabilities === null) {
        console.warn('Capabilities not yet received, assuming signing is available');
        bunkerCapabilities = new Set(['sign_event', 'ping', 'get_public_key']);
    }

    if (!bunkerCapabilities.has('sign_event')) {
        throw new Error('Remote signer does not support signing. Your signer app may be in read-only mode.');
    }

    try {
        console.log('=== SIGNING EVENT WITH BUNKER ===');
        console.log('Event to sign:', event);
        console.log('User pubkey:', currentUser.pubkey);
        console.log('Remote signer pubkey:', bunkerConnection.remotePubkey);
        
        // Create a completely clean event object with only the required fields
const eventToSign = {
    kind: event.kind,
    created_at: event.created_at,
    tags: event.tags,
    content: event.content,
    pubkey: currentUser.pubkey
};
        
        const requestId = crypto.randomUUID();
        const request = {
            id: requestId,
            method: 'sign_event',
            params: [eventToSign]
        };
        
        console.log('Sign request ID:', requestId);
        
        const relays = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://relay.nsec.app'];
        const clientPubkey = NostrTools.getPublicKey(bunkerConnection.clientSecret);
        
        console.log('Client pubkey (listening on):', clientPubkey);
        console.log('Remote signer pubkey:', bunkerConnection.remotePubkey);
        
        return new Promise(async (resolve, reject) => {
            let resolved = false;
            let sub = null;
            let authPopup = null;
            
            const timeout = setTimeout(() => {
                if (!resolved) {
                    console.error('=== TIMEOUT ===');
                    console.error('Never received response for request ID:', requestId);
                    if (sub) sub.close();
                    if (authPopup) authPopup.close();
                    reject(new Error('Signing timeout - please check if your remote signer app is open and approve the request'));
                }
            }, 120000); // 2 minutes for web-based approval
            
            try {
                console.log('Setting up subscription BEFORE publishing...');
                sub = pool.subscribeMany(relays, [
                    {
                        kinds: [24133],
                        '#p': [clientPubkey],
                        since: Math.floor(Date.now() / 1000) - 30
                    }
                ], {
                    async onevent(responseEvent) {
                        console.log('=== RECEIVED RESPONSE EVENT ===');
                        console.log('Response from:', responseEvent.pubkey);
                        console.log('Expected from:', bunkerConnection.remotePubkey);
                        console.log('Event kind:', responseEvent.kind);
                        console.log('Event created_at:', responseEvent.created_at);
                        
                        if (responseEvent.pubkey !== bunkerConnection.remotePubkey) {
                            console.log('Event not from our remote signer, ignoring');
                            return;
                        }
                        
                        try {
                            console.log('Decrypting response...');
                            console.log('Raw encrypted content length:', responseEvent.content.length);
                            
                            let decrypted;
                            if (NostrTools.nip44) {
                                const conversationKey = NostrTools.nip44.getConversationKey(
                                    bunkerConnection.clientSecret,
                                    responseEvent.pubkey
                                );
                                decrypted = NostrTools.nip44.decrypt(responseEvent.content, conversationKey);
                            } else {
                                const secretKeyHex = Array.from(bunkerConnection.clientSecret)
                                    .map(b => b.toString(16).padStart(2, '0'))
                                    .join('');
                                decrypted = await NostrTools.nip04.decrypt(secretKeyHex, responseEvent.pubkey, responseEvent.content);
                            }
                            
                            console.log('Decrypted response:', decrypted);
                            
                            const response = JSON.parse(decrypted);
                            console.log('Parsed response:', response);
                            console.log('Response ID:', response.id);
                            console.log('Expected ID:', requestId);
                            
                            if (response.id === requestId) {
                                // Handle auth_url response (nsec.app web approval)
                                if (response.result === 'auth_url' && response.error) {
                                    console.log('=== AUTH URL RECEIVED ===');
                                    console.log('Opening approval URL:', response.error);
                                    
                                    // Open the auth URL in a popup
                                    authPopup = window.open(
                                        response.error,
                                        'nsec-approval',
                                        'width=500,height=600,popup=yes'
                                    );
                                    
                                    console.log('Waiting for user to approve in popup...');
                                    return;
                                }
                                
                                // Handle actual signed event response
                                if (response.result && typeof response.result === 'object' && response.result.sig) {
                                    console.log('=== SUCCESS ===');
                                    console.log('Signed event:', response.result);
                                    
                                    if (!resolved) {
                                        resolved = true;
                                        clearTimeout(timeout);
                                        sub.close();
                                        if (authPopup) authPopup.close();
                                        resolve(response.result);
                                    }
                                } else if (response.result === 'error' || response.error) {
                                    console.error('=== ERROR from signer ===');
                                    console.error('Error:', response.error || response.result);
                                    
                                    if (!resolved) {
                                        resolved = true;
                                        clearTimeout(timeout);
                                        sub.close();
                                        if (authPopup) authPopup.close();
                                        reject(new Error('Signing failed: ' + (response.error || 'Unknown error')));
                                    }
                                }
                            } else {
                                console.log('Response ID does not match');
                                console.log('  Got:', response.id);
                                console.log('  Expected:', requestId);
                            }
                        } catch (err) {
                            console.error('Error processing response:', err);
                            console.error('Stack:', err.stack);
                        }
                    },
                    oneose() {
                        console.log('Sign subscription EOSE');
                    }
                });
                
                console.log('Subscription created, waiting 2 seconds for it to be ready...');
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                console.log('Encrypting and publishing sign request...');
                let encrypted;
                if (NostrTools.nip44) {
                    const conversationKey = NostrTools.nip44.getConversationKey(
                        bunkerConnection.clientSecret, 
                        bunkerConnection.remotePubkey
                    );
                    encrypted = NostrTools.nip44.encrypt(JSON.stringify(request), conversationKey);
                } else {
                    const secretKeyHex = Array.from(bunkerConnection.clientSecret)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                    encrypted = await NostrTools.nip04.encrypt(secretKeyHex, bunkerConnection.remotePubkey, JSON.stringify(request));
                }
                
                const unsignedNip46Event = {
                    kind: 24133,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [['p', bunkerConnection.remotePubkey]],
                    content: encrypted,
                    pubkey: clientPubkey
                };
                
                const nip46Event = NostrTools.finalizeEvent(unsignedNip46Event, bunkerConnection.clientSecret);
                
                console.log('Publishing sign request event ID:', nip46Event.id);
                console.log('Request payload:', JSON.stringify(request));
                
                const publishResults = await Promise.allSettled(
                    relays.map(relay => pool.publish([relay], nip46Event))
                );
                
                const successCount = publishResults.filter(r => r.status === 'fulfilled').length;
                console.log(`Published to ${successCount}/${relays.length} relays`);
                
                if (successCount === 0) {
                    throw new Error('Failed to publish to any relay');
                }
                
                console.log('Sign request published successfully, waiting for response...');
                console.log('Monitoring for responses to request ID:', requestId);
            } catch (err) {
                console.error('Error in signing flow:', err);
                if (!resolved) {
                    resolved = true;
                    clearTimeout(timeout);
                    if (sub) sub.close();
                    if (authPopup) authPopup.close();
                    reject(err);
                }
            }
        });
    } catch (err) {
        console.error('Signing error:', err);
        throw err;
    }
}

async function requestSignerCapabilities(remotePubkey, clientSecret) {
    console.log('=== REQUESTING SIGNER CAPABILITIES ===');
    
    const requestId = crypto.randomUUID();
    const request = {
        id: requestId,
        method: 'get_capabilities',
        params: []
    };

    const relays = ['wss://relay.primal.net', 'wss://relay.damus.io', 'wss://relay.nsec.app'];
    const clientPubkey = NostrTools.getPublicKey(clientSecret);

    // Encrypt and send request
    let encrypted;
    if (NostrTools.nip44) {
        const conversationKey = NostrTools.nip44.getConversationKey(clientSecret, remotePubkey);
        encrypted = NostrTools.nip44.encrypt(JSON.stringify(request), conversationKey);
    } else {
        const secretKeyHex = Array.from(clientSecret)
            .map(b => b.toString(16).padStart(2, '0'))
            .join('');
        encrypted = await NostrTools.nip04.encrypt(
            secretKeyHex,
            remotePubkey,
            JSON.stringify(request)
        );
    }

    const unsignedEvent = {
        kind: 24133,
        created_at: Math.floor(Date.now() / 1000),
        tags: [['p', remotePubkey]],
        content: encrypted,
        pubkey: clientPubkey
    };

    const event = NostrTools.finalizeEvent(unsignedEvent, clientSecret);
    
    console.log('Publishing capabilities request...');
    await Promise.all(relays.map(r => pool.publish([r], event)));
}

    // [REST OF THE CODE REMAINS THE SAME - fetchProfile, fetchRecentNotes, etc.]
    // I'll continue in next message due to length...

    // Fetch functions
    async function fetchProfile(pubkeyHex) {
        if (profileCache.has(pubkeyHex)) return profileCache.get(pubkeyHex);

        try {
            const events = await pool.querySync(RELAYS, { kinds: [0], authors: [pubkeyHex], limit: 1 });

            if (events.length === 0) {
                return { pubkey: pubkeyHex, name: 'Anonymous', about: '', picture: null };
            }

            const profile = JSON.parse(events[0].content);
            profile.pubkey = pubkeyHex;
            profileCache.set(pubkeyHex, profile);
            return profile;
        } catch (err) {
            console.error('Profile fetch error:', err);
            return { pubkey: pubkeyHex, name: 'Anonymous', about: '', picture: null };
        }
    }

    async function fetchRecentNotes(pubkeyHex, limit = 25) {
    if (noteCache.has(pubkeyHex)) return noteCache.get(pubkeyHex);

    try {
        const events = await pool.querySync(RELAYS, { kinds: [1], authors: [pubkeyHex], limit });
        noteCache.set(pubkeyHex, events);
        return events;
    } catch (err) {
        return [];
    }
}

    async function fetchFollows(pubkeyHex) {
        try {
            const events = await pool.querySync(RELAYS, { kinds: [3], authors: [pubkeyHex], limit: 1 });
            if (events.length === 0) return [];
            return events[0].tags.filter(tag => tag[0] === 'p').map(tag => tag[1]);
        } catch (err) {
            return [];
        }
    }

    async function batchFetch(items, fetchFn, batchSize = 10, delayMs = 150) {
    const results = [];
    
    for (let i = 0; i < items.length; i += batchSize) {
        const batch = items.slice(i, i + batchSize);
        console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(items.length / batchSize)}`);
        
        try {
            const batchResults = await Promise.all(
                batch.map(item => fetchFn(item).catch(err => {
                    console.error('Batch item error:', err);
                    return null;
                }))
            );
            
            results.push(...batchResults);
        } catch (err) {
            console.error('Batch error:', err);
            results.push(...Array(batch.length).fill(null));
        }
        
        if (i + batchSize < items.length) {
            await new Promise(resolve => setTimeout(resolve, delayMs));
        }
    }
    
    return results;
}

    async function searchUsersByHashtags(hashtags, limit = 50) {
        console.log('Searching posts for hashtags:', hashtags);
        
        const userCandidates = new Map();
        const hashtagArray = Array.from(hashtags);
        
        try {
            for (const tag of hashtagArray) {
                console.log('Searching for #' + tag);
                
                const events = await pool.querySync(RELAYS, {
                    kinds: [1],
                    '#t': [tag.toLowerCase()],
                    limit: 100
                });
                
                console.log(`Found ${events.length} posts for #${tag}`);
                
                events.forEach(event => {
                    const count = userCandidates.get(event.pubkey) || 0;
                    userCandidates.set(event.pubkey, count + 1);
                });

                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            const sortedUsers = Array.from(userCandidates.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, limit)
                .map(([pubkey]) => pubkey);
            
            console.log(`Found ${sortedUsers.length} unique users posting about these topics`);
            return sortedUsers;
        } catch (err) {
            console.error('Hashtag search error:', err);
            return [];
        }
    }

    // Scoring function
    function calculateMatchScore(userProfile, candidateProfile, userFollows, candidateFollows, candidateNotes, searchTags = null) {
        let scores = {
            social: 0,
            interests: 0,
            engagement: 0,
            niche: 0,
            hashtag: 0
        };

        if (userFollows && candidateFollows) {
            const mutualFollows = candidateFollows.filter(f => userFollows.includes(f)).length;
            const followsYou = candidateFollows.includes(userProfile.pubkey);
            scores.social = Math.min(100, (mutualFollows * 10) + (followsYou ? 20 : 0));
        }

        const userBioHashtags = (userProfile.about || '').match(/#\w+/gi) || [];
        const candidateBioHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];

        const userPostHashtags = new Set();
        if (candidateNotes) {
            candidateNotes.forEach(note => {
                const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                tags.forEach(tag => userPostHashtags.add(tag));
            });
        }

        const allCandidateHashtags = [
            ...candidateBioHashtags.map(h => h.toLowerCase().replace('#', '')),
            ...Array.from(userPostHashtags)
        ];

        const sharedHashtags = userBioHashtags.filter(h => 
            allCandidateHashtags.some(ch => ch === h.toLowerCase().replace('#', ''))
        ).length;

        scores.interests = Math.min(100, sharedHashtags * 25);

        if (candidateNotes && candidateNotes.length > 0) {
            const avgNotesPerDay = candidateNotes.length / 7;
            scores.engagement = Math.min(100, avgNotesPerDay * 15);
        }

        const candidateBioTags = (candidateProfile.about || '').match(/#\w+/gi) || [];
        const candidatePostTags = new Set();
        if (candidateNotes) {
            candidateNotes.forEach(note => {
                const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                tags.forEach(tag => candidatePostTags.add(tag));
            });
        }

        const allTopics = [
            ...candidateBioTags.map(h => h.toLowerCase().replace('#', '')),
            ...Array.from(candidatePostTags)
        ];

        if (allTopics.length > 0 && window.topicPopularity) {
            const rarityScores = allTopics.map(topic => {
                const popularity = window.topicPopularity.get(topic) || 1;
                const totalProfiles = window.topicPopularity.size;
                const rarityPercent = (popularity / totalProfiles) * 100;
                return rarityPercent < 10 ? (100 - rarityPercent * 5) : 0;
            });
            
            const avgRarity = rarityScores.reduce((a, b) => a + b, 0) / rarityScores.length;
            scores.niche = Math.min(100, Math.max(0, avgRarity));
        } else {
            scores.niche = 0;
        }

        if (searchTags && searchTags.size > 0) {
            const bioHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];
            const postHashtags = new Set();
            if (candidateNotes) {
                candidateNotes.forEach(note => {
                    const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                    tags.forEach(tag => postHashtags.add(tag));
                });
            }
            
            const allCandidateHashtags = [
                ...bioHashtags.map(h => h.toLowerCase().replace('#', '')),
                ...Array.from(postHashtags)
            ];
            
            const searchArray = Array.from(searchTags);
            const matches = searchArray.filter(tag => 
                allCandidateHashtags.some(ct => ct.includes(tag))
            );
            
            if (matchMode === 'all') {
                scores.hashtag = matches.length === searchArray.length ? 100 : 0;
            } else {
                scores.hashtag = Math.min(100, (matches.length / searchArray.length) * 100);
            }
        }

        let finalScore = 0;
        switch(discoveryMode) {
            case 'social':
                finalScore = scores.social * 0.7 + scores.interests * 0.2 + scores.engagement * 0.1;
                break;
            case 'interests':
                finalScore = scores.interests * 0.7 + scores.social * 0.2 + scores.niche * 0.1;
                break;
            case 'niche':
                finalScore = scores.niche * 0.7 + scores.interests * 0.2 + scores.social * 0.1;
                break;
            case 'hashtags':
                finalScore = scores.hashtag * 0.8 + scores.engagement * 0.15 + scores.social * 0.05;
                break;
        }

        return {
            total: Math.min(99, Math.max(60, Math.round(finalScore))),
            breakdown: scores
        };
    }

    async function getRecommendations(userPubkey, limit) {
        const userFollows = await fetchFollows(userPubkey);
        
        console.log('User follows:', userFollows.length);
        
        if (userFollows.length === 0) {
            console.log('No follows found, searching popular users...');
            
            try {
                const recentEvents = await pool.querySync(RELAYS, { kinds: [1], limit: 200 });
                
                const userCounts = new Map();
                recentEvents.forEach(event => {
                    const count = userCounts.get(event.pubkey) || 0;
                    userCounts.set(event.pubkey, count + 1);
                });
                
                const topUsers = Array.from(userCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, limit * 3)
                    .map(([pubkey]) => pubkey);
                
                console.log('Found', topUsers.length, 'popular users');
                return topUsers;
            } catch (err) {
                console.error('Error finding popular users:', err);
                return [
                    '82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2',
                    '460c25e682fda7832b52d1f22d3d22b3176d972f60dcdc3212ed8c92ef85065c',
                    '3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d'
                ];
            }
        }

        const candidates = new Set();
        const sampleSize = Math.min(20, userFollows.length);
        
        console.log('Sampling', sampleSize, 'of your', userFollows.length, 'follows');
        
        const shuffledFollows = [...userFollows].sort(() => Math.random() - 0.5);
        
        const followPromises = [];
        for (let i = 0; i < sampleSize; i++) {
            followPromises.push(fetchFollows(shuffledFollows[i]));
        }

        const results = await Promise.all(followPromises);
        
        results.forEach(theirFollows => {
            theirFollows.forEach(pubkey => {
                if (pubkey !== userPubkey && !userFollows.includes(pubkey)) {
                    candidates.add(pubkey);
                }
            });
        });

        const candidateArray = Array.from(candidates).sort(() => Math.random() - 0.5);
        console.log('Generated', candidateArray.length, 'total candidates');
        
        return candidateArray.slice(0, limit * 5);
    }

    async function followUser(pubkey) {
    if (!currentUser) {
        alert('Please login first');
        return false;
    }

    const useBunker = currentUser.bunker && bunkerConnection;
    const useExtension = !useBunker && await checkExtension();

    if (!useBunker && !useExtension) {
        alert('No signing method available');
        return false;
    }

    try {
        // Get current follows and deduplicate
        const currentFollows = Array.from(userFollowing);
        
        // Don't include ourselves in the follow list!
        const cleanFollows = currentFollows.filter(pk => pk !== currentUser.pubkey);
        
        // Add the new follow if not already following
        if (!cleanFollows.includes(pubkey) && pubkey !== currentUser.pubkey) {
            cleanFollows.push(pubkey);
        }

        console.log('=== CREATING FOLLOW EVENT ===');
        console.log('Current user pubkey:', currentUser.pubkey);
        console.log('Adding follow for:', pubkey);
        console.log('Total follows after:', cleanFollows.length);
        console.log('Includes self?', cleanFollows.includes(currentUser.pubkey));

        // Create a clean event object - ensure everything is serializable
        const event = {
            kind: 3,
            created_at: Math.floor(Date.now() / 1000),
            tags: cleanFollows.map(pk => ['p', pk]),
            content: ''
        };

        // Validate the event structure
        console.log('Event structure:', JSON.stringify(event, null, 2));
        console.log('Event to sign has', event.tags.length, 'follow tags');

        let signedEvent;
        
        if (useBunker) {
            try {
                console.log('Requesting signature from remote signer...');
                
                // Make absolutely sure we're passing a clean object
                const cleanEvent = JSON.parse(JSON.stringify(event));
                signedEvent = await signEventWithBunker(cleanEvent);
                
                if (!signedEvent) {
                    throw new Error('Bunker signing returned null');
                }
                
                console.log('Successfully signed event:', signedEvent.id);
            } catch (err) {
                console.error('Bunker signing failed:', err);
                alert('Signing failed: ' + err.message + '\n\nMake sure your remote signer app is open and approve the request.');
                throw err;
            }
        } else {
            signedEvent = await window.nostr.signEvent(event);
        }

        console.log('Publishing signed event to relays...');
        await Promise.all(RELAYS.map(relay => pool.publish([relay], signedEvent)));
        
        console.log('Successfully published follow event');
        userFollowing.add(pubkey);
        return true;
    } catch (err) {
        console.error('Follow error:', err);
        return false;
    }
}

    function createProfileCard(fren) {
    const card = document.createElement('div');
    card.className = 'fren-card';
    
    if (fren.isFollowing) {
        card.classList.add('already-following');
    }
    
    const about = fren.about || '';
    const hashtags = (about.match(/#\w+/g) || []).slice(0, 3).map(t => t.substring(1));
    
    let metricsHTML = '<div class="metrics-container">';
    
    if (fren.crossRefCategory) {
        if (fren.crossRefCategory === 'mutual') {
            metricsHTML += `<span class="metric-badge high">Both Follow</span>`;
        } else if (fren.crossRefCategory === 'you-only') {
            metricsHTML += `<span class="metric-badge medium">You Follow</span>`;
        } else if (fren.crossRefCategory === 'them-only') {
            metricsHTML += `<span class="metric-badge medium">They Follow</span>`;
        }
    }
    
    if (fren.scores.breakdown.social > 40) {
        metricsHTML += `<span class="metric-badge high">${fren.mutual || 0} Mutual</span>`;
    }
    if (fren.scores.breakdown.interests > 40) {
        metricsHTML += `<span class="metric-badge medium">${hashtags.length} Tags</span>`;
    }
    
    // NEW: Check if posted within the last hour
    const oneHourAgo = Math.floor(Date.now() / 1000) - 3600;
    const postedRecently = fren.notes?.some(note => note.created_at > oneHourAgo);
    if (postedRecently) {
        metricsHTML += `<span class="metric-badge high">Active</span>`;
    }
    
    metricsHTML += '</div>';
    
    const name = fren.name || 'Anonymous';
    const picture = fren.picture || `https://robohash.org/${fren.pubkey}?set=set5`;
    const bioText = about.substring(0, 150) + (about.length > 150 ? '...' : '');
    
    card.innerHTML = `
        <div class="fren-header">
            <img src="${picture}" 
                 class="fren-avatar" 
                 onerror="this.src='https://robohash.org/${fren.pubkey}?set=set5'">
            <div class="fren-info">
                <div class="fren-name">${name}</div>
                <div class="fren-npub" onclick="copyNpub('${fren.npub}')">${fren.npub.substring(0,20)}...</div>
            </div>
            <div class="match-score">${fren.scores.total}%</div>
        </div>
        <p class="fren-bio">${bioText}</p>
        ${metricsHTML}
        ${hashtags.length > 0 ? `
            <div class="tags-container">
                ${hashtags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
            </div>
        ` : ''}
        <div class="fren-actions">
            <button class="btn-follow ${fren.isFollowing ? 'following' : ''}" 
                    data-pubkey="${fren.pubkey}"
                    ${!currentUser ? 'disabled' : ''}>
                ${fren.isFollowing ? 'Following' : 'Follow'}
            </button>
            <a href="https://njump.me/${fren.npub}" target="_blank" class="btn-view-profile">View</a>
        </div>
    `;

    const followBtn = card.querySelector('.btn-follow');
    followBtn.addEventListener('click', async () => {
        if (fren.isFollowing) return;
        followBtn.disabled = true;
        followBtn.textContent = 'Following...';
        const success = await followUser(fren.pubkey);
        if (success) {
            followBtn.textContent = 'Following';
            followBtn.classList.add('following');
            fren.isFollowing = true;
        } else {
            followBtn.disabled = false;
            followBtn.textContent = 'Follow';
        }
    });

    return card;
}

    function renderResults(profiles) {
        const resultsGrid = document.getElementById('results-grid');
        resultsGrid.innerHTML = '';

        profiles.forEach(fren => {
            const card = createProfileCard(fren);
            resultsGrid.appendChild(card);
        });
    }

    // Main search
    document.getElementById('find-btn').addEventListener('click', async () => {
        const findBtn = document.getElementById('find-btn');
        const resultsSection = document.getElementById('results-section');
        const emptyState = document.getElementById('empty-state');
        const resultsGrid = document.getElementById('results-grid');

        if (discoveryMode === 'hashtags') {
            if (selectedHashtags.size === 0) {
                alert('Please select at least one hashtag to search');
                return;
            }
            console.log('Hashtag discovery mode:', Array.from(selectedHashtags), 'Match mode:', matchMode);
        }

        let userPubkey;

        if (currentUser && currentUser.pubkey) {
            userPubkey = currentUser.pubkey;
        } else {
            const npubInput = document.getElementById('npub-input').value.trim();

            if (!npubInput) {
                alert('Please enter your npub or login');
                return;
            }

            if (!npubInput.startsWith('npub1')) {
                alert('Invalid npub format');
                return;
            }

            userPubkey = nip19.decode(npubInput).data;
        }

        if (findBtn.disabled) return;

        findBtn.disabled = true;
        findBtn.textContent = 'Discovering...';
        emptyState.style.display = 'none';
        resultsSection.style.display = 'block';
        resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';

        try {
            const userProfile = await fetchProfile(userPubkey);
            const userFollows = await fetchFollows(userPubkey);

            if (!currentUser) {
                userFollowing = new Set(userFollows);
                console.log('Loaded follows for manual npub:', userFollowing.size);
            }

            let candidatePubkeys;

            if (discoveryMode === 'hashtags' && selectedHashtags.size > 0) {
                resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Searching posts for matching hashtags...</p>';
                candidatePubkeys = await searchUsersByHashtags(selectedHashtags, parseInt(document.getElementById('result-count').value) * 3);
            } else if (crossRefEnabled && crossRefData) {
                const allCandidates = [
                    ...crossRefData.youOnly,
                    ...crossRefData.themOnly,
                    ...crossRefData.mutual
                ];
                
                candidatePubkeys = Array.from(new Set(allCandidates))
                    .slice(0, parseInt(document.getElementById('result-count').value) * 2);
                
                resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Comparing networks...</p>';
            } else {
                candidatePubkeys = await getRecommendations(userPubkey, parseInt(document.getElementById('result-count').value));
                resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';
            }

            resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Calculating match scores...</p>';

            console.log('Fetching', candidatePubkeys.length, 'profiles, follows, and notes...');

            const [allProfiles, allFollows, allNotes] = await Promise.all([
    batchFetch(candidatePubkeys, fetchProfile, 10, 150),
    batchFetch(candidatePubkeys, fetchFollows, 10, 150),
    batchFetch(candidatePubkeys, (pk) => fetchRecentNotes(pk, 25), 10, 150)
]);

            const topicPopularity = new Map();
            allNotes.forEach((notes, idx) => {
                if (!notes) return;
                const profile = allProfiles[idx];
                if (!profile) return;
                
                const bioHashtags = (profile.about || '').match(/#\w+/gi) || [];
                bioHashtags.forEach(tag => {
                    const normalized = tag.toLowerCase().replace('#', '');
                    topicPopularity.set(normalized, (topicPopularity.get(normalized) || 0) + 1);
                });
                
                notes.forEach(note => {
                    const tags = note.tags?.filter(t => t[0] === 't').map(t => t[1].toLowerCase()) || [];
                    tags.forEach(tag => {
                        topicPopularity.set(tag, (topicPopularity.get(tag) || 0) + 1);
                    });
                });
            });

            console.log('Topic popularity map built:', topicPopularity.size, 'unique topics');
            window.topicPopularity = topicPopularity;

            const profiles = allProfiles
                .map((profile, idx) => {
                    if (!profile.pubkey) return null;
                    
                    const spamScore = detectSpam(profile, allNotes[idx]);
                    const isNSFW = detectNSFW(profile);
                    
                    const scores = calculateMatchScore(
                        userProfile,
                        profile,
                        userFollows,
                        allFollows[idx],
                        allNotes[idx],
                        discoveryMode === 'hashtags' ? selectedHashtags : null
                    );

                    const mutual = allFollows[idx].filter(f => userFollows.includes(f)).length;

                    let crossRefCategory = null;
                    if (crossRefEnabled && crossRefData) {
                        if (crossRefData.mutual.includes(profile.pubkey)) {
                            crossRefCategory = 'mutual';
                        } else if (crossRefData.youOnly.includes(profile.pubkey)) {
                            crossRefCategory = 'you-only';
                        } else if (crossRefData.themOnly.includes(profile.pubkey)) {
                            crossRefCategory = 'them-only';
                        }
                    }

                    return {
                        ...profile,
                        npub: nip19.npubEncode(profile.pubkey),
                        scores: scores,
                        mutual: mutual,
                        isFollowing: userFollowing.has(profile.pubkey),
                        spamScore: spamScore,
                        isNSFW: isNSFW,
                        crossRefCategory: crossRefCategory,
                        notes: allNotes[idx],
                        follows: allFollows[idx]
                    };
                })
                .filter(p => {
                    if (!p) return false;
                    
                    if (discoveryMode === 'hashtags' && p.scores.breakdown.hashtag === 0) return false;
                    
                    const hideSpam = document.getElementById('hide-spam').checked;
                    if (hideSpam && p.spamScore > 60) return false;
                    
                    const hideNSFW = document.getElementById('hide-nsfw').checked;
                    if (hideNSFW && p.isNSFW) return false;
                    
                    const recentActivityOnly = document.getElementById('recent-activity-only').checked;
                    if (recentActivityOnly) {
                        const thirtyDaysAgo = Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);
                        const hasRecentNote = p.notes?.some(note => note.created_at > thirtyDaysAgo);
                        if (!hasRecentNote) return false;
                    }
                    
                    const minFollowers = parseInt(document.getElementById('min-followers').value);
                    if (minFollowers > 0) {
                        const followCount = p.follows?.length || 0;
                        if (followCount < minFollowers) return false;
                    }
                    
                    const activityLevel = document.getElementById('activity-level').value;
                    if (activityLevel !== 'any' && p.notes) {
                        const tenDaysAgo = Math.floor(Date.now() / 1000) - (10 * 24 * 60 * 60);
                        const thirtyDaysAgo = Math.floor(Date.now() / 1000) - (30 * 24 * 60 * 60);
                        
                        const recentPosts = p.notes.filter(note => note.created_at > tenDaysAgo).length;
                        const monthPosts = p.notes.filter(note => note.created_at > thirtyDaysAgo).length;
                        
                        if (activityLevel === 'high' && recentPosts < 5) return false;
                        if (activityLevel === 'medium' && recentPosts < 2) return false;
                        if (activityLevel === 'low' && monthPosts < 1) return false;
                    }
                    
                    return true;
                })
                .sort((a, b) => b.scores.total - a.scores.total)
                .slice(0, parseInt(document.getElementById('result-count').value));

            const hideFollowing = document.getElementById('hide-following').checked;
            
            let newProfiles, followingProfiles;
            
            if (hideFollowing) {
                newProfiles = profiles.filter(p => !p.isFollowing);
                followingProfiles = profiles.filter(p => p.isFollowing);
            } else {
                newProfiles = profiles;
                followingProfiles = [];
            }

            document.getElementById('results-count').textContent = `${newProfiles.length} matches`;

            if (newProfiles.length === 0 && followingProfiles.length > 0) {
                resultsGrid.innerHTML = `
                    <div style="text-align:center;padding:3rem;">
                        <h3 style="margin-bottom:1rem;">No New Discoveries</h3>
                        <p style="color:var(--text-secondary);">All ${followingProfiles.length} matches are people you already follow.</p>
                        <p style="color:var(--text-secondary);margin-top:0.5rem;">Try unchecking "Hide Already Following" or searching with different criteria.</p>
                    </div>
                `;
            } else {
                renderResults(newProfiles);
            }

            const followingSection = document.getElementById('following-section');
            const followingGrid = document.getElementById('following-grid');

            if (followingProfiles.length > 0 && hideFollowing && newProfiles.length > 0) {
                followingSection.style.display = 'block';
                document.getElementById('following-count').textContent = followingProfiles.length;
                
                followingGrid.innerHTML = '';
                followingProfiles.forEach(fren => {
                    const card = createProfileCard(fren);
                    followingGrid.appendChild(card);
                });
            } else {
                followingSection.style.display = 'none';
                followingGrid.innerHTML = '';
            }
        } catch (err) {
            console.error('Error:', err);
            resultsGrid.innerHTML = `<p style="text-align:center;padding:2rem;color:var(--accent-primary)">Error: ${err.message}</p>`;
        } finally {
            findBtn.disabled = false;
            findBtn.textContent = 'Discover Frens';
        }
    });

    document.getElementById('npub-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') document.getElementById('find-btn').click();
    });

    window.copyNpub = (npub) => {
        navigator.clipboard.writeText(npub).then(() => console.log('Copied:', npub));
    };

    document.getElementById('following-header').addEventListener('click', function() {
        const content = document.getElementById('following-content');
        const icon = document.getElementById('following-icon');
        
        if (content.style.display === 'none') {
            content.style.display = 'block';
            icon.textContent = '▼';
        } else {
            content.style.display = 'none';
            icon.textContent = '▶';
        }
    });

    document.getElementById('close-bunker').addEventListener('click', function() {
    document.getElementById('bunker-login-modal').classList.remove('visible');
    bunkerLoginInProgress = false;
    if (window._bunkerSub) {
        window._bunkerSub.close();
        window._bunkerSub = null;
    }
});

document.getElementById('bunker-login-modal').addEventListener('click', function(e) {
    if (e.target === this) {
        this.classList.remove('visible');
        bunkerLoginInProgress = false;
        if (window._bunkerSub) {
            window._bunkerSub.close();
            window._bunkerSub = null;
        }
    }
});

    updateUserUI();
});
</script>