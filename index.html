<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fren Finder - Advanced Nostr Discovery</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@300;400;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #faf8f5;
            --bg-secondary: #f0ede7;
            --bg-tertiary: #e8e3da;
            --text-primary: #1a1512;
            --text-secondary: #5a524a;
            --text-tertiary: #8a7f72;
            --accent-primary: #c84e3a;
            --accent-secondary: #2d5f4f;
            --accent-success: #2d7a4f;
            --accent-info: #3a6ea5;
            --border-color: #d4cec2;
            --shadow-color: rgba(26, 21, 18, 0.08);
            --transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1512;
            --bg-secondary: #2a2319;
            --bg-tertiary: #3a3229;
            --text-primary: #faf8f5;
            --text-secondary: #c4beb4;
            --text-tertiary: #8a7f72;
            --accent-primary: #e8745e;
            --accent-secondary: #4a9276;
            --accent-success: #4a9a70;
            --accent-info: #5a8ec5;
            --border-color: #3a3229;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            transition: var(--transition);
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        header {
            padding: 3rem 0 2rem;
            border-bottom: 1px solid var(--border-color);
            animation: fadeInDown 0.6s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .logo-section h1 {
            font-size: 3.5rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
        }

        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: var(--transition);
            font-weight: 600;
            border: none;
        }

        .btn-login {
            background: var(--accent-primary);
            color: var(--bg-primary);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .btn-logout {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .theme-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .theme-toggle:hover, .btn-logout:hover {
            background: var(--bg-tertiary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        main {
            padding: 3rem 0;
            animation: fadeIn 0.8s ease-out 0.2s both;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .search-section {
            margin-bottom: 3rem;
        }

        .input-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
            font-weight: 600;
        }

        input[type="text"] {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }

        input[type="text"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .discovery-mode {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .mode-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
        }

        .mode-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .mode-card.active {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            box-shadow: 0 4px 16px var(--shadow-color);
        }

        .mode-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.25rem;
        }

        .mode-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        select {
            padding: 0.875rem 1.25rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: var(--transition);
        }

        select:focus {
            outline: none;
            border-color: var(--accent-secondary);
        }

        .btn-primary {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 1rem 2.5rem;
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(200, 78, 58, 0.3);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .results-section {
            display: none;
        }

        .results-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 1rem;
        }

        .results-header h2 {
            font-size: 2rem;
            font-weight: 600;
        }

        .results-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .results-count {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .sort-dropdown {
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            margin-top: 2rem;
        }

        .fren-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.75rem;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .fren-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-primary);
            transform: scaleY(0);
            transition: var(--transition);
        }

        .fren-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px var(--shadow-color);
            border-color: var(--accent-primary);
        }

        .fren-card:hover::before {
            transform: scaleY(1);
        }

        .fren-card.already-following {
            opacity: 0.6;
            background: var(--bg-tertiary);
        }

        .fren-card.already-following:hover {
            opacity: 0.8;
        }

        .fren-header {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .fren-avatar {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
            flex-shrink: 0;
        }

        .fren-info {
            flex: 1;
            min-width: 0;
        }

        .fren-name {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .fren-npub {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: var(--transition);
            padding: 0.25rem;
            border-radius: 0.25rem;
        }

        .fren-npub:hover {
            color: var(--accent-primary);
        }

        .match-score {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            padding: 0.4rem 0.8rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .fren-bio {
            color: var(--text-secondary);
            margin-bottom: 1.25rem;
            font-size: 1rem;
            line-height: 1.6;
        }

        .metrics-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .metric-badge {
            background: var(--bg-tertiary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .metric-badge.high {
            background: var(--accent-success);
            color: var(--bg-primary);
            border-color: var(--accent-success);
        }

        .metric-badge.medium {
            background: var(--accent-info);
            color: var(--bg-primary);
            border-color: var(--accent-info);
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.25rem;
        }

        .tag {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid var(--border-color);
        }

        .fren-actions {
            display: flex;
            gap: 0.75rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .btn-follow {
            flex: 1;
            padding: 0.75rem;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
        }

        .btn-follow:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(200, 78, 58, 0.2);
        }

        .btn-follow:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-follow.following {
            background: var(--accent-success);
        }

        .btn-view-profile {
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            color: var(--text-primary);
            display: inline-block;
        }

        .btn-view-profile:hover {
            background: var(--bg-secondary);
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        footer {
            border-top: 1px solid var(--border-color);
            padding: 2rem 0;
            margin-top: 4rem;
            text-align: center;
            color: var(--text-tertiary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }

        .toggle-group {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border-radius: 0.75rem;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background-color: var(--bg-primary);
        }

        .toggle-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .already-following-section {
            margin-top: 3rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .following-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .following-header h3 {
            font-size: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .following-count {
            background: var(--accent-info);
            color: var(--bg-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .following-toggle-icon {
            font-size: 1.5rem;
            transition: var(--transition);
        }

        .following-toggle-icon.expanded {
            transform: rotate(180deg);
        }

        .following-content {
            display: none;
            padding-top: 1.5rem;
        }

        .following-content.visible {
            display: block;
        }

        .hashtag-search-container {
            display: none;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 2px solid var(--accent-primary);
            border-radius: 0.75rem;
        }

        .hashtag-search-container.visible {
            display: block;
        }

        .hashtag-input-wrapper {
            position: relative;
            margin-bottom: 1rem;
        }

        .hashtag-input {
            width: 100%;
            padding: 1rem 1.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            transition: var(--transition);
        }

        .hashtag-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .hashtag-input::placeholder {
            color: var(--text-tertiary);
        }

        .tag-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 0.5rem 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 10;
        }

        .tag-suggestions.visible {
            display: block;
        }

        .tag-suggestion-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }

        .tag-suggestion-item:hover {
            background: var(--bg-secondary);
        }

        .selected-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
            min-height: 2.5rem;
        }

        .selected-tag {
            background: var(--accent-primary);
            color: var(--bg-primary);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .tag-remove {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2rem;
            line-height: 1;
        }

        .tag-remove:hover {
            transform: scale(1.2);
        }

        .match-mode-toggle {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .match-mode-btn {
            flex: 1;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-transform: uppercase;
            font-weight: 600;
        }

        .match-mode-btn.active {
            background: var(--accent-secondary);
            color: var(--bg-primary);
            border-color: var(--accent-secondary);
        }

        .match-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .popular-tags {
            margin-top: 1rem;
        }

        .popular-tags-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .popular-tags-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .popular-tag {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .popular-tag:hover {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .cross-reference-container {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.75rem;
        }

        .cross-ref-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cross-ref-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .cross-ref-toggle-switch {
            position: relative;
            width: 40px;
            height: 22px;
        }

        .cross-ref-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .cross-ref-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            transition: var(--transition);
            border-radius: 34px;
        }

        .cross-ref-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-primary);
            transition: var(--transition);
            border-radius: 50%;
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider {
            background-color: var(--accent-info);
            border-color: var(--accent-info);
        }

        .cross-ref-toggle-switch input:checked + .cross-ref-toggle-slider:before {
            transform: translateX(18px);
            background-color: var(--bg-primary);
        }

        .cross-ref-input {
            width: 100%;
            padding: 0.875rem 1.25rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            font-family: 'Crimson Pro', serif;
            font-size: 1rem;
            color: var(--text-primary);
            transition: var(--transition);
            display: none;
        }

        .cross-ref-input.visible {
            display: block;
        }

        .cross-ref-input:focus {
            outline: none;
            border-color: var(--accent-info);
        }

        .comparison-results {
            margin-top: 2rem;
            display: none;
        }

        .comparison-results.visible {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }

        .comparison-category {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .comparison-category h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 1rem;
            color: var(--accent-info);
        }

        .comparison-count {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .comparison-desc {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .bunker-login-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            padding: 2rem;
            overflow-y: auto;
        }

        .bunker-login-modal.visible {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .bunker-login-content {
            background: var(--bg-primary);
            border: 2px solid var(--accent-info);
            border-radius: 0.75rem;
            padding: 2rem;
            max-width: 500px;
            width: 100%;
            text-align: center;
        }

        .bunker-login-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
        }

        .bunker-login-header h3 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.25rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-info);
        }

        .bunker-close {
            font-size: 2rem;
            cursor: pointer;
            line-height: 1;
            color: var(--text-secondary);
            transition: var(--transition);
        }

        .bunker-close:hover {
            color: var(--accent-primary);
            transform: scale(1.2);
        }

        .bunker-instructions {
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .bunker-instructions ol {
            text-align: left;
            padding-left: 1.5rem;
            margin-top: 1rem;
        }

        .bunker-instructions li {
            margin-bottom: 0.5rem;
        }

        .qr-code-container {
            background: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1.5rem auto;
            max-width: 300px;
        }

        .bunker-connection-string {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            word-break: break-all;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            max-height: 100px;
            overflow-y: auto;
        }

        .bunker-status {
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .bunker-status.waiting {
            color: var(--accent-info);
        }

        .bunker-status.connected {
            color: var(--accent-success);
        }

        .bunker-status.error {
            color: var(--accent-primary);
        }

        .btn-bunker {
            background: var(--accent-info);
            color: var(--bg-primary);
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 2rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(58, 110, 165, 0.2);
            transition: var(--transition);
        }

        .btn-bunker:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(58, 110, 165, 0.3);
        }

        .login-dropdown {
            position: relative;
        }

        .login-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 0.5rem;
            box-shadow: 0 8px 24px var(--shadow-color);
            z-index: 100;
            min-width: 200px;
        }

        .login-menu.visible {
            display: block;
        }

        .login-option {
            padding: 0.875rem 1.25rem;
            cursor: pointer;
            transition: var(--transition);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-color);
        }

        .login-option:last-child {
            border-bottom: none;
        }

        .login-option:hover {
            background: var(--bg-secondary);
        }

        @media (max-width: 768px) {
            .logo-section h1 { font-size: 2.5rem; }
            .header-content { flex-direction: column; }
            .filter-row { grid-template-columns: 1fr; }
            .results-grid { grid-template-columns: 1fr; }
            .discovery-mode { grid-template-columns: 1fr; }
            .toggle-group { flex-direction: column; gap: 1rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="logo-section">
                    <h1>Fren Finder</h1>
                    <p class="subtitle">Advanced Nostr Discovery</p>
                </div>
                <div class="header-actions">
                    <div id="user-section"></div>
                    <button class="btn theme-toggle" id="theme-btn">Toggle Theme</button>
                </div>
            </div>
        </header>

        <main>
            <section class="search-section">
                <div class="input-group">
                    <label for="npub-input">Your Nostr Public Key</label>
                    <input type="text" id="npub-input" placeholder="npub1... (or click Login)">
                </div>

                <div class="cross-reference-container">
                    <div class="cross-ref-toggle">
                        <label class="cross-ref-toggle-switch">
                            <input type="checkbox" id="enable-cross-ref">
                            <span class="cross-ref-toggle-slider"></span>
                        </label>
                        <div class="cross-ref-label">
                            Cross-Reference With Another Account
                        </div>
                    </div>
                    <input type="text" 
                           class="cross-ref-input" 
                           id="cross-ref-input" 
                           placeholder="Enter another npub to compare networks">
                    
                    <div class="comparison-results" id="comparison-results">
                        <div class="comparison-category">
                            <h4>You Follow</h4>
                            <div class="comparison-count" id="you-only-count">0</div>
                            <div class="comparison-desc">Accounts only you follow</div>
                        </div>
                        <div class="comparison-category">
                            <h4>Both Follow</h4>
                            <div class="comparison-count" id="mutual-count">0</div>
                            <div class="comparison-desc">Shared connections</div>
                        </div>
                        <div class="comparison-category">
                            <h4>They Follow</h4>
                            <div class="comparison-count" id="them-only-count">0</div>
                            <div class="comparison-desc">Accounts only they follow</div>
                        </div>
                    </div>
                </div>

                <div class="input-group">
                    <label>Discovery Mode</label>
                    <div class="discovery-mode">
                        <div class="mode-card active" data-mode="social">
                            <div class="mode-title">Social Graph</div>
                            <div class="mode-desc">Friends of friends</div>
                        </div>
                        <div class="mode-card" data-mode="interests">
                            <div class="mode-title">Shared Interests</div>
                            <div class="mode-desc">Hashtag matching</div>
                        </div>
                        <div class="mode-card" data-mode="engagement">
                            <div class="mode-title">High Engagement</div>
                            <div class="mode-desc">Active posters</div>
                        </div>
                        <div class="mode-card" data-mode="niche">
                            <div class="mode-title">Niche Communities</div>
                            <div class="mode-desc">Specific topics</div>
                        </div>
                        <div class="mode-card" data-mode="hashtags">
                            <div class="mode-title">Hashtag Discovery</div>
                            <div class="mode-desc">Search by tags</div>
                        </div>
                    </div>
                </div>

                <div class="hashtag-search-container" id="hashtag-search">
                    <div class="hashtag-input-wrapper">
                        <input type="text" 
                               class="hashtag-input" 
                               id="hashtag-input" 
                               placeholder="Enter hashtags (e.g., bitcoin, nostr, photography)">
                        <div class="tag-suggestions" id="tag-suggestions"></div>
                    </div>

                    <div class="selected-tags" id="selected-tags"></div>

                    <div class="match-mode-toggle">
                        <button class="match-mode-btn active" id="match-any">Match ANY Tag</button>
                        <button class="match-mode-btn" id="match-all">Match ALL Tags</button>
                    </div>

                    <div class="popular-tags">
                        <div class="popular-tags-label">Popular Tags</div>
                        <div class="popular-tags-grid" id="popular-tags"></div>
                    </div>
                </div>

                <div class="toggle-group">
                    <div class="toggle-item">
                        <label class="toggle-switch">
                            <input type="checkbox" id="hide-spam" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Hide Spam</span>
                    </div>

                    <div class="toggle-item">
                        <label class="toggle-switch">
                            <input type="checkbox" id="hide-nsfw" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Hide NSFW</span>
                    </div>

                    <div class="toggle-item">
                        <label class="toggle-switch">
                            <input type="checkbox" id="hide-following" checked>
                            <span class="toggle-slider"></span>
                        </label>
                        <span class="toggle-label">Hide Already Following</span>
                    </div>
                </div>

                <div class="filter-row">
                    <div class="input-group">
                        <label for="min-followers">Min Network Size</label>
                        <select id="min-followers">
                            <option value="0">Any Size</option>
                            <option value="10">Small (10+)</option>
                            <option value="50">Medium (50+)</option>
                            <option value="100">Large (100+)</option>
                            <option value="500">Very Large (500+)</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="activity-level">Activity Level</label>
                        <select id="activity-level">
                            <option value="any">Any Activity</option>
                            <option value="high">Very Active</option>
                            <option value="medium">Moderately Active</option>
                            <option value="low">Occasional</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label for="result-count">Results</label>
                        <select id="result-count">
                            <option value="10">10 Profiles</option>
                            <option value="25">25 Profiles</option>
                            <option value="50">50 Profiles</option>
                        </select>
                    </div>
                </div>

                <button class="btn-primary" id="find-btn">Discover Frens</button>
            </section>

            <div class="bunker-login-modal" id="bunker-login-modal">
                <div class="bunker-login-content">
                    <div class="bunker-login-header">
                        <h3>Remote Signer Login</h3>
                        <span class="bunker-close" id="close-bunker">×</span>
                    </div>
                    <div class="bunker-instructions">
                        <p><strong>Instructions for Remote Signing:</strong></p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>For Amber (Android):</strong><br>
                            1. Open Amber app<br>
                            2. Tap "Connect Application"<br>
                            3. Scan QR code or paste connection string<br>
                            4. Approve the connection
                        </p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>For Nsec.app:</strong><br>
                            1. Go to nsec.app on mobile<br>
                            2. Tap "Connect"<br>
                            3. Scan QR code<br>
                            4. Approve permissions
                        </p>
                        
                        <p style="margin-top: 1rem; color: var(--text-secondary); font-size: 0.9rem;">
                            <strong>Manual Setup:</strong><br>
                            Copy the connection string below and paste into your signing app
                        </p>
                    </div>
                    <div class="qr-code-container" id="qr-code-container"></div>
                    <div class="bunker-connection-string" id="bunker-connection-string"></div>
                    <button class="btn-primary" id="copy-connection-btn" style="margin-top: 1rem; display: none;">
                        Copy Connection String
                    </button>
                    <div class="bunker-status waiting" id="bunker-status">Waiting for connection...</div>
                </div>
            </div>

            <section class="results-section" id="results-section">
                <div class="results-header">
                    <h2>Discovered Frens</h2>
                    <div class="results-info">
                        <span class="results-count" id="results-count">0 matches</span>
                        <select class="sort-dropdown" id="sort-by">
                            <option value="match">Best Match</option>
                            <option value="followers">Most Followers</option>
                            <option value="mutual">Most Mutual</option>
                            <option value="recent">Recently Active</option>
                        </select>
                    </div>
                </div>
                <div class="results-grid" id="results-grid"></div>

                <div class="already-following-section" id="following-section" style="display: none;">
                    <div class="following-header" id="following-header">
                        <h3>People You Already Follow</h3>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <span class="following-count" id="following-count">0</span>
                            <span class="following-toggle-icon" id="following-icon">▼</span>
                        </div>
                    </div>
                    <div class="following-content" id="following-content">
                        <div class="results-grid" id="following-grid"></div>
                    </div>
                </div>
            </section>

            <section id="empty-state" class="empty-state">
                <h3>Discover Your Nostr Community</h3>
                <p>Choose a discovery mode and find people based on multiple matching signals</p>
            </section>
        </main>

        <footer>
            <p>Fren Finder - Advanced Discovery for Nostr</p>
        </footer>
    </div>

    <script type="module">
    import { SimplePool, nip19, generateSecretKey, getPublicKey, finalizeEvent } from 'https://esm.sh/nostr-tools@2.7.2';
    import * as nip04 from 'https://esm.sh/nostr-tools@2.7.2/nip04';
    
    // Import BunkerSigner and parseBunkerInput directly
    import { BunkerSigner, parseBunkerInput } from 'https://esm.sh/nostr-tools@2.7.2/nip46';
    
    window.NostrTools = { 
        SimplePool, 
        nip19, 
        generateSecretKey, 
        getPublicKey, 
        finalizeEvent, 
        nip04,
        nip46: { BunkerSigner, parseBunkerInput }
    };
</script>
<script src="https://unpkg.com/qrcode-generator@1.4.4/qrcode.js"></script>

<script>
        const profileCache = new Map();  
        const noteCache = new Map();
        let currentUser = null;
        let userFollowing = new Set();
        let discoveryMode = 'social';
        let bunkerConnection = null;
        let bunkerPubkey = null;

        

        window.addEventListener('load', async function() {
    // Timeout helper for mobile performance ← ✅ Added!
    function withTimeout(promise, ms, errorMsg) {
        return Promise.race([
            promise,
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error(errorMsg)), ms)
            )
        ]);
    }
    
    if (typeof NostrTools === 'undefined') {
        alert('Failed to load Nostr tools');
        return;
    }

            const { nip19, SimplePool } = NostrTools;
            const pool = new SimplePool();
            const RELAYS = ['wss://relay.damus.io', 'wss://nos.lol', 'wss://relay.nostr.band'];

            // Theme toggle
            document.getElementById('theme-btn').addEventListener('click', () => {
                const html = document.documentElement;
                const theme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                html.setAttribute('data-theme', theme);
                localStorage.setItem('theme', theme);
            });
            document.documentElement.setAttribute('data-theme', localStorage.getItem('theme') || 'light');

            // Spam detection function
            function detectSpam(profile, notes) {
                let spamScore = 0;
                const name = (profile.name || '').toLowerCase();
                const about = (profile.about || '').toLowerCase();
                
                // Check for common spam phrases
                const spamPhrases = [
                    'hello world',
                    'test test',
                    'testing 123',
                    'this is a test',
                    'hello nostr',
                    'first post',
                    'new here'
                ];

                
                
                for (const phrase of spamPhrases) {
                    if (about.includes(phrase) && about.length < 50) {
                        spamScore += 30;
                    }
                }
                
                // Empty or very short bio
                if (about.length === 0) spamScore += 20;
                if (about.length > 0 && about.length < 10) spamScore += 15;
                
                // Suspicious name patterns
                if (name.match(/^user\d+$/i)) spamScore += 25;
                if (name.match(/^anon\d+$/i)) spamScore += 20;
                if (name === 'anon' || name === '') spamScore += 10;
                
                // No profile picture
                if (!profile.picture) spamScore += 10;
                
                // No recent activity
                if (notes && notes.length === 0) spamScore += 20;
                if (notes && notes.length === 1) spamScore += 10;
                
                // Very repetitive content
                if (notes && notes.length > 1) {
                    const contents = notes.map(n => n.content.toLowerCase());
                    const uniqueContents = new Set(contents);
                    if (uniqueContents.size < notes.length / 2) {
                        spamScore += 15;
                    }
                }
                
                return spamScore; // 0-100, higher = more likely spam
            }

            // NSFW detection function
            function detectNSFW(profile) {
                const about = (profile.about || '').toLowerCase();
                const name = (profile.name || '').toLowerCase();
                
                const nsfwTags = [
                    '#nsfw',
                    '#xxx',
                    '#adult',
                    '#18+',
                    '#porn',
                    '#onlyfans',
                    'nsfw',
                    '18+'
                ];
                
                for (const tag of nsfwTags) {
                    if (about.includes(tag) || name.includes(tag)) {
                        return true;
                    }
                }
                
                return false;
            }

            // Discovery mode selection
            document.querySelectorAll('.mode-card').forEach(card => {
                card.addEventListener('click', function() {
                    document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('active'));
                    this.classList.add('active');
                    discoveryMode = this.dataset.mode;
                    
                    // Show/hide hashtag search interface
                    const hashtagSearch = document.getElementById('hashtag-search');
                    if (discoveryMode === 'hashtags') {
                        hashtagSearch.classList.add('visible');
                    } else {
                        hashtagSearch.classList.remove('visible');
                    }
                });
            });

            // Hashtag discovery setup
            const selectedHashtags = new Set();
            let matchMode = 'any'; // 'any' or 'all'

            const POPULAR_TAGS = [
                'bitcoin', 'nostr', 'lightning', 'crypto', 'privacy',
                'art', 'photography', 'music', 'writing', 'design',
                'coding', 'tech', 'ai', 'web3', 'freedom',
                'travel', 'food', 'fitness', 'nature', 'coffee',
                'startup', 'business', 'marketing', 'trading', 'investing'
            ];

            const TAG_SUGGESTIONS = [
                'bitcoin', 'nostr', 'lightning', 'crypto', 'btc',
                'art', 'photography', 'music', 'artist', 'creative',
                'coding', 'developer', 'programming', 'tech', 'software',
                'design', 'ui', 'ux', 'web', 'frontend',
                'writing', 'author', 'blog', 'content', 'writer',
                'privacy', 'security', 'opensource', 'linux', 'decentralized',
                'travel', 'adventure', 'nature', 'hiking', 'outdoors',
                'food', 'cooking', 'recipe', 'chef', 'foodie',
                'fitness', 'health', 'yoga', 'running', 'gym',
                'gaming', 'game', 'gamer', 'esports', 'streamer',
                'business', 'startup', 'entrepreneur', 'founder', 'investing',
                'philosophy', 'science', 'history', 'education', 'learning'
            ];

            // Render popular tags
            function renderPopularTags() {
                const container = document.getElementById('popular-tags');
                container.innerHTML = '';
                POPULAR_TAGS.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'popular-tag';
                    tagEl.textContent = `#${tag}`;
                    tagEl.addEventListener('click', () => addHashtag(tag));
                    container.appendChild(tagEl);
                });
            }
            renderPopularTags();

            // Add hashtag to selection
            function addHashtag(tag) {
                const normalized = tag.toLowerCase().replace(/^#/, '');
                if (!selectedHashtags.has(normalized)) {
                    selectedHashtags.add(normalized);
                    renderSelectedTags();
                }
                document.getElementById('hashtag-input').value = '';
                document.getElementById('tag-suggestions').classList.remove('visible');
            }

            // Remove hashtag from selection
            function removeHashtag(tag) {
                selectedHashtags.delete(tag);
                renderSelectedTags();
            }

            // Render selected tags
            function renderSelectedTags() {
                const container = document.getElementById('selected-tags');
                container.innerHTML = '';
                
                if (selectedHashtags.size === 0) {
                    container.innerHTML = '<div style="color: var(--text-tertiary); font-style: italic;">No tags selected</div>';
                    return;
                }

                selectedHashtags.forEach(tag => {
                    const tagEl = document.createElement('div');
                    tagEl.className = 'selected-tag';
                    tagEl.innerHTML = `
                        #${tag}
                        <span class="tag-remove" onclick="removeHashtag('${tag}')">×</span>
                    `;
                    container.appendChild(tagEl);
                });
            }
            renderSelectedTags();

            // Make removeHashtag available globally
            window.removeHashtag = removeHashtag;

            // Cross-reference toggle
            let crossRefEnabled = false;
            let crossRefData = null;

            document.getElementById('enable-cross-ref').addEventListener('change', function() {
                crossRefEnabled = this.checked;
                const crossRefInput = document.getElementById('cross-ref-input');
                const comparisonResults = document.getElementById('comparison-results');
                
                if (crossRefEnabled) {
                    crossRefInput.classList.add('visible');
                } else {
                    crossRefInput.classList.remove('visible');
                    comparisonResults.classList.remove('visible');
                    crossRefData = null;
                }
            });

            // Analyze cross-reference when input changes
            document.getElementById('cross-ref-input').addEventListener('blur', async function() {
                const crossRefNpub = this.value.trim();
                
                if (!crossRefNpub || !crossRefNpub.startsWith('npub1')) {
                    return;
                }

                const mainNpub = document.getElementById('npub-input').value.trim();
                if (!mainNpub || !mainNpub.startsWith('npub1')) {
                    alert('Please enter your main npub first');
                    return;
                }

                try {
                    // Fetch both follow lists
                    const { data: mainPubkey } = nip19.decode(mainNpub);
                    const { data: crossPubkey } = nip19.decode(crossRefNpub);

                    const mainFollows = await fetchFollows(mainPubkey);
                    const crossFollows = await fetchFollows(crossPubkey);

                    // Calculate overlaps
                    const mainSet = new Set(mainFollows);
                    const crossSet = new Set(crossFollows);

                    const youOnly = mainFollows.filter(p => !crossSet.has(p));
                    const themOnly = crossFollows.filter(p => !mainSet.has(p));
                    const mutual = mainFollows.filter(p => crossSet.has(p));

                    // Store for later use
                    crossRefData = {
                        youOnly: youOnly,
                        themOnly: themOnly,
                        mutual: mutual
                    };

                    // Display comparison stats
                    document.getElementById('you-only-count').textContent = youOnly.length;
                    document.getElementById('mutual-count').textContent = mutual.length;
                    document.getElementById('them-only-count').textContent = themOnly.length;
                    document.getElementById('comparison-results').classList.add('visible');

                } catch (err) {
                    console.error('Cross-reference error:', err);
                    alert('Failed to analyze cross-reference');
                }
            });

            // Check for extension
            async function checkExtension() {
                return typeof window.nostr !== 'undefined';
            }

            // Login
            async function loginWithExtension() {
                if (typeof window.nostr === 'undefined') {
                    alert('Please install a Nostr browser extension (Alby, nos2x)');
                    return null;
                }

                try {
                    const pubkey = await window.nostr.getPublicKey();
                    const npub = nip19.npubEncode(pubkey);
                    const profile = await fetchProfile(pubkey);
                    currentUser = { pubkey, npub, profile };
                    const follows = await fetchFollows(pubkey);
                    userFollowing = new Set(follows);
                    updateUserUI();
                    document.getElementById('npub-input').value = npub;
                    document.getElementById('npub-input').disabled = true;
                    return npub;
                } catch (err) {
                    console.error('Login error:', err);
                    alert('Failed to login');
                    return null;
                }
            }

            function logout() {
                currentUser = null;
                userFollowing.clear();
                document.getElementById('npub-input').value = '';
                document.getElementById('npub-input').disabled = false;
                updateUserUI();
            }

            function updateUserUI() {
                const userSection = document.getElementById('user-section');
                if (currentUser) {
                    const name = currentUser.profile?.name || 'Anon';
                    const picture = currentUser.profile?.picture || `https://robohash.org/${currentUser.pubkey}?set=set5`;
                    userSection.innerHTML = `
                        <div class="user-info">
                            <img src="${picture}" class="user-avatar" onerror="this.src='https://robohash.org/${currentUser.pubkey}?set=set5'">
                            <span>${name}</span>
                        </div>
                        <button class="btn btn-logout" id="logout-btn">Logout</button>
                    `;
                    document.getElementById('logout-btn').addEventListener('click', logout);
                } else {
                    userSection.innerHTML = `
                        <div class="login-dropdown">
                            <button class="btn btn-login" id="login-btn">Login</button>
                            <div class="login-menu" id="login-menu">
                                <div class="login-option" id="extension-login">Extension Login</div>
                                <div class="login-option" id="bunker-login-option">Remote Signer</div>
                            </div>
                        </div>
                    `;
                    
                    const loginBtn = document.getElementById('login-btn');
                    const loginMenu = document.getElementById('login-menu');
                    
                    loginBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        loginMenu.classList.toggle('visible');
                    });
                    
                    document.getElementById('extension-login').addEventListener('click', function() {
                        loginMenu.classList.remove('visible');
                        loginWithExtension();
                    });
                    
                    document.getElementById('bunker-login-option').addEventListener('click', function() {
                        loginMenu.classList.remove('visible');
                        showBunkerLogin();
                    });
                    
                    // Close menu when clicking outside
                    document.addEventListener('click', function() {
                        loginMenu.classList.remove('visible');
                    });
                }
            }

            // Get or create client secret
function getClientSecret() {
    let secret = localStorage.getItem('bunker_client_secret');
    if (!secret) {
        const secretKey = NostrTools.generateSecretKey();
        secret = Array.from(secretKey).map(b => b.toString(16).padStart(2, '0')).join('');
        localStorage.setItem('bunker_client_secret', secret);
    }
    return secret;
}

            // Bunker login using official BunkerSigner (same as Primal)
let bunkerSigner = null;
let bunkerAbortController = null;

function showBunkerLogin() {
    const modal = document.getElementById('bunker-login-modal');
    const statusEl = document.getElementById('bunker-status');
    const qrContainer = document.getElementById('qr-code-container');
    const connectionStringEl = document.getElementById('bunker-connection-string');
    
    qrContainer.innerHTML = '';
    connectionStringEl.textContent = '';
    
    bunkerAbortController = new AbortController();
    
    // Get or create persistent client secret
    const clientSecret = getClientSecret();
    const secretBytes = new Uint8Array(clientSecret.match(/.{2}/g).map(byte => parseInt(byte, 16)));
    const clientPubkey = NostrTools.getPublicKey(secretBytes);
    
    // Generate bunker URL (nostrconnect://)
    const relayUrl = 'wss://relay.damus.io';
    const metadata = {
        name: 'Fren Finder',
        url: window.location.origin,
        perms: 'sign_event:3,get_public_key'
    };
    
    const metadataParam = encodeURIComponent(JSON.stringify(metadata));
    const connectionString = `nostrconnect://${clientPubkey}?relay=${encodeURIComponent(relayUrl)}&metadata=${metadataParam}`;
    
    console.log('Bunker URL:', connectionString);
    connectionStringEl.textContent = connectionString;
    
    // Generate QR code
    try {
        if (typeof qrcode !== 'undefined') {
            const qr = qrcode(0, 'L');
            qr.addData(connectionString);
            qr.make();
            
            const canvas = document.createElement('canvas');
            canvas.width = 200;
            canvas.height = 200;
            const ctx = canvas.getContext('2d');
            const cellSize = 200 / qr.getModuleCount();
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 200, 200);
            
            ctx.fillStyle = '#000000';
            for (let row = 0; row < qr.getModuleCount(); row++) {
                for (let col = 0; col < qr.getModuleCount(); col++) {
                    if (qr.isDark(row, col)) {
                        ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            qrContainer.appendChild(canvas);
        }
    } catch (err) {
        console.error('QR error:', err);
    }
    
    modal.classList.add('visible');
    statusEl.className = 'bunker-status waiting';
    statusEl.textContent = 'Scan with your signer app...';
    
    // Copy button
    const copyBtn = document.getElementById('copy-connection-btn');
    copyBtn.style.display = 'block';
    copyBtn.onclick = () => {
        navigator.clipboard.writeText(connectionString).then(() => {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => copyBtn.textContent = 'Copy Connection String', 2000);
        });
    };
    
    // Connect using official BunkerSigner
    connectBunker(connectionString, secretBytes, statusEl);
    
    // Timeout
    setTimeout(() => {
        if (!bunkerAbortController.signal.aborted) {
            statusEl.className = 'bunker-status error';
            statusEl.textContent = 'Connection timeout';
        }
    }, 60000);
}

async function connectBunker(bunkerUrl, clientSecret, statusEl) {
    try {
        const { BunkerSigner } = NostrTools.nip46;
        
        statusEl.className = 'bunker-status waiting';
        statusEl.textContent = 'Connecting to signer...';
        
        // Parse the nostrconnect URL manually
        const url = new URL(bunkerUrl);
        const remotePubkey = url.hostname || url.pathname.replace('//', '');
        const relayParam = url.searchParams.get('relay');
        
        if (!remotePubkey || !relayParam) {
            throw new Error('Invalid connection URL format');
        }
        
        console.log('Remote pubkey:', remotePubkey);
        console.log('Relay:', relayParam);
        
        // Create bunker pointer object
        const bunkerPointer = {
            pubkey: remotePubkey,
            relays: [relayParam]
        };
        
        // Create BunkerSigner using direct constructor
        bunkerSigner = new BunkerSigner(clientSecret, bunkerPointer, {
            onauth: (url) => {
                console.log('Auth URL:', url);
                window.open(url, '_blank');
            }
        });
        
        // Connect to the signer
        await bunkerSigner.connect();
        
        statusEl.className = 'bunker-status connected';
        statusEl.textContent = 'Connected! Getting your key...';
        
        // Get public key
        const userPubkey = await bunkerSigner.getPublicKey();
        
        if (userPubkey) {
            await completeBunkerLogin(userPubkey, statusEl);
        } else {
            throw new Error('Failed to get public key');
        }
        
    } catch (err) {
        console.error('Bunker connection error:', err);
        statusEl.className = 'bunker-status error';
        statusEl.textContent = 'Connection failed: ' + err.message;
    }
}

            async function completeBunkerLogin(userPubkey, statusEl) {
    try {
        console.log('Completing login:', userPubkey);
        
        const npub = nip19.npubEncode(userPubkey);
        const profile = await fetchProfile(userPubkey);
        currentUser = { pubkey: userPubkey, npub, profile, bunker: true };
        const follows = await fetchFollows(userPubkey);
        userFollowing = new Set(follows);
        
        // Store bunker connection
        bunkerConnection = {
            signer: bunkerSigner,
            pubkey: userPubkey
        };
        
        statusEl.className = 'bunker-status connected';
        statusEl.textContent = 'Login successful!';
        
        setTimeout(() => {
            document.getElementById('bunker-login-modal').classList.remove('visible');
            updateUserUI();
            document.getElementById('npub-input').value = npub;
            document.getElementById('npub-input').disabled = true;
        }, 1500);
    } catch (err) {
        console.error('Login error:', err);
        statusEl.className = 'bunker-status error';
        statusEl.textContent = 'Login failed: ' + err.message;
    }
}

            // Fetch profile with cache
            async function fetchProfile(pubkeyHex) {
                if (profileCache.has(pubkeyHex)) return profileCache.get(pubkeyHex);

                try {
                    const events = await pool.querySync(RELAYS, {
                        kinds: [0],
                        authors: [pubkeyHex],
                        limit: 1
                    });

                    if (events.length === 0) {
                        const fallback = { pubkey: pubkeyHex, name: 'Anon', about: '', picture: null };
                        profileCache.set(pubkeyHex, fallback);
                        return fallback;
                    }

                    const profile = JSON.parse(events[0].content);
                    const data = {
                        pubkey: pubkeyHex,
                        name: profile.name || profile.display_name || 'Anon',
                        about: profile.about || '',
                        picture: profile.picture || null
                    };
                    
                    profileCache.set(pubkeyHex, data);
                    return data;
                } catch (err) {
                    const fallback = { pubkey: pubkeyHex, name: 'Anon', about: '', picture: null };
                    profileCache.set(pubkeyHex, fallback);
                    return fallback;
                }
            }

            // Fetch recent notes for engagement analysis
            async function fetchRecentNotes(pubkeyHex, limit = 10) {
                if (noteCache.has(pubkeyHex)) return noteCache.get(pubkeyHex);

                try {
                    const events = await pool.querySync(RELAYS, {
                        kinds: [1],
                        authors: [pubkeyHex],
                        limit: limit
                    });

                    noteCache.set(pubkeyHex, events);
                    return events;
                } catch (err) {
                    return [];
                }
            }

            // Fetch follows
            async function fetchFollows(pubkeyHex) {
                try {
                    const events = await pool.querySync(RELAYS, {
                        kinds: [3],
                        authors: [pubkeyHex],
                        limit: 1
                    });

                    if (events.length === 0) return [];

                    return events[0].tags
                        .filter(tag => tag[0] === 'p')
                        .map(tag => tag[1]);
                } catch (err) {
                    return [];
                }
            }

            // Calculate advanced match score based on multiple metrics
            // SCORING BREAKDOWN:
            // 
            // Social Score (0-100):
            //   - Each mutual follow = +10 points
            //   - If they follow you = +20 bonus
            // 
            // Interest Score (0-100):
            //   - Each shared hashtag = +25 points
            //   - Compares hashtags in your bio vs theirs
            // 
            // Engagement Score (0-100):
            //   - Based on recent posting activity
            //   - More posts = higher score
            // 
            // Niche Score (0-100):
            //   - Measures topic consistency
            //   - High = focused on specific topics
            //   - Low = diverse interests
            // 
            // FINAL SCORE depends on selected mode:
            //   Social Graph: 70% social, 20% interests, 10% engagement
            //   Shared Interests: 70% interests, 20% social, 10% niche
            //   High Engagement: 70% engagement, 20% social, 10% interests
            //   Niche Communities: 70% niche, 20% interests, 10% social
            //   Hashtag Discovery: 100% hashtag match based on selected tags
            function calculateMatchScore(userProfile, candidateProfile, userFollows, candidateFollows, candidateNotes, searchTags = null) {
                let scores = {
                    social: 0,      // Friend graph overlap
                    interests: 0,   // Shared hashtags/topics
                    engagement: 0,  // Activity level
                    niche: 0,       // Specific topic depth
                    hashtag: 0      // Hashtag search match
                };

                // Social graph analysis
                if (userFollows && candidateFollows) {
                    const mutualFollows = candidateFollows.filter(f => userFollows.includes(f)).length;
                    const followsYou = candidateFollows.includes(userProfile.pubkey);
                    scores.social = Math.min(100, (mutualFollows * 10) + (followsYou ? 20 : 0));
                }

                // Interest matching (hashtags)
                const userHashtags = (userProfile.about || '').match(/#\w+/gi) || [];
                const candidateHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];
                const sharedHashtags = userHashtags.filter(h => 
                    candidateHashtags.some(ch => ch.toLowerCase() === h.toLowerCase())
                ).length;
                scores.interests = Math.min(100, sharedHashtags * 25);

                // Engagement analysis
                if (candidateNotes && candidateNotes.length > 0) {
                    const avgNotesPerDay = candidateNotes.length / 7; // Assuming last week
                    scores.engagement = Math.min(100, avgNotesPerDay * 15);
                }

                // Niche community detection (hashtag consistency)
                if (candidateHashtags.length > 0) {
                    const uniqueTopics = new Set(candidateHashtags.map(h => h.toLowerCase())).size;
                    const topicDepth = candidateHashtags.length / uniqueTopics;
                    scores.niche = Math.min(100, topicDepth * 20);
                }

                // Hashtag search matching (for hashtag discovery mode)
                if (searchTags && searchTags.size > 0) {
                    const candidateHashtags = (candidateProfile.about || '').match(/#\w+/gi) || [];
                    const candidateTagsLower = candidateHashtags.map(h => h.toLowerCase().replace('#', ''));
                    
                    const searchArray = Array.from(searchTags);
                    const matches = searchArray.filter(tag => 
                        candidateTagsLower.some(ct => ct.includes(tag))
                    );
                    
                    if (matchMode === 'all') {
                        // ALL tags must be present
                        scores.hashtag = matches.length === searchArray.length ? 100 : 0;
                    } else {
                        // ANY tag match
                        scores.hashtag = Math.min(100, (matches.length / searchArray.length) * 100);
                    }
                }

                // Weight scores based on discovery mode
                let finalScore = 0;
                switch(discoveryMode) {
                    case 'social':
                        finalScore = scores.social * 0.7 + scores.interests * 0.2 + scores.engagement * 0.1;
                        break;
                    case 'interests':
                        finalScore = scores.interests * 0.7 + scores.social * 0.2 + scores.niche * 0.1;
                        break;
                    case 'engagement':
                        finalScore = scores.engagement * 0.7 + scores.social * 0.2 + scores.interests * 0.1;
                        break;
                    case 'niche':
                        finalScore = scores.niche * 0.7 + scores.interests * 0.2 + scores.social * 0.1;
                        break;
                    case 'hashtags':
                        finalScore = scores.hashtag * 0.8 + scores.engagement * 0.15 + scores.social * 0.05;
                        break;
                }

                return {
                    total: Math.min(99, Math.max(60, Math.round(finalScore))),
                    breakdown: scores
                };
            }

            // Get recommendations based on discovery mode
            // HOW IT WORKS:
            // 1. Fetches your follow list (people you follow)
            // 2. Samples 10 of your follows
            // 3. Gets their follow lists (second-degree connections)
            // 4. Filters out people you already follow and yourself
            // 5. Returns candidates for scoring
            async function getRecommendations(userPubkey, limit) {
                const userFollows = await fetchFollows(userPubkey);
                
                if (userFollows.length === 0) {
                    return [
                        '82341f882b6eabcd2ba7f1ef90aad961cf074af15b9ef44a09f9d2a8fbfbe6a2',
                        '460c25e682fda7832b52d1f22d3d22b3176d972f60dcdc3212ed8c92ef85065c',
                        '3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d'
                    ];
                }

                const candidates = new Set();
                const sampleSize = Math.min(15, userFollows.length);
                
                // Randomize which follows to sample from
                const shuffledFollows = [...userFollows].sort(() => Math.random() - 0.5);
                
                // Get second-degree connections
                const followPromises = [];
                for (let i = 0; i < sampleSize; i++) {
                    followPromises.push(fetchFollows(shuffledFollows[i]));
                }

                const results = await Promise.all(followPromises);
                
                results.forEach(theirFollows => {
                    theirFollows.forEach(pubkey => {
                        if (pubkey !== userPubkey && !userFollows.includes(pubkey)) {
                            candidates.add(pubkey);
                        }
                    });
                });

                // Randomize candidates and return more than needed
                const candidateArray = Array.from(candidates).sort(() => Math.random() - 0.5);
                return candidateArray.slice(0, limit * 3);
            }

            // Follow user
            async function followUser(pubkey) {
                if (!currentUser) {
                    alert('Please login first');
                    return false;
                }

                // Check if using bunker or extension
                const useBunker = currentUser.bunker && bunkerConnection;
                const useExtension = !useBunker && await checkExtension();

                if (!useBunker && !useExtension) {
                    alert('No signing method available');
                    return false;
                }

                try {
                    const currentFollows = Array.from(userFollowing);
                    if (!currentFollows.includes(pubkey)) {
                        currentFollows.push(pubkey);
                    }

                    const event = {
                        kind: 3,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: currentFollows.map(pk => ['p', pk]),
                        content: ''
                    };

                    let signedEvent;
                    
                    if (useBunker) {
                        // Sign with bunker
                        signedEvent = await signEventWithBunker(event);
                        if (!signedEvent) {
                            throw new Error('Bunker signing failed');
                        }
                    } else {
                        // Sign with extension
                        signedEvent = await window.nostr.signEvent(event);
                    }

                    await Promise.all(RELAYS.map(relay => pool.publish([relay], signedEvent)));
                    userFollowing.add(pubkey);
                    return true;
                } catch (err) {
                    console.error('Follow error:', err);
                    return false;
                }
            }

            // Sign event using BunkerSigner
async function signEventWithBunker(event) {
    if (!bunkerConnection || !bunkerConnection.signer) {
        throw new Error('Bunker not connected');
    }
    
    try {
        // Use official signer's signEvent method
        const signedEvent = await bunkerConnection.signer.signEvent(event);
        return signedEvent;
    } catch (err) {
        console.error('Bunker signing error:', err);
        throw err;
    }
}

            // Create profile card (reusable function)
            function createProfileCard(fren) {
                const card = document.createElement('div');
                card.className = 'fren-card';
                
                // Add class if already following
                if (fren.isFollowing) {
                    card.classList.add('already-following');
                }
                
                const hashtags = (fren.about.match(/#\w+/g) || []).slice(0, 3).map(t => t.substring(1));
                
                // Determine which metrics to highlight
                let metricsHTML = '<div class="metrics-container">';
                
                // Add cross-reference badge if applicable
                if (fren.crossRefCategory) {
                    if (fren.crossRefCategory === 'mutual') {
                        metricsHTML += `<span class="metric-badge high">Both Follow</span>`;
                    } else if (fren.crossRefCategory === 'you-only') {
                        metricsHTML += `<span class="metric-badge medium">You Follow</span>`;
                    } else if (fren.crossRefCategory === 'them-only') {
                        metricsHTML += `<span class="metric-badge medium">They Follow</span>`;
                    }
                }
                
                if (fren.scores.breakdown.social > 40) {
                    metricsHTML += `<span class="metric-badge high">${fren.mutual || 0} Mutual</span>`;
                }
                if (fren.scores.breakdown.interests > 40) {
                    metricsHTML += `<span class="metric-badge medium">${hashtags.length} Tags</span>`;
                }
                if (fren.scores.breakdown.engagement > 40) {
                    metricsHTML += `<span class="metric-badge high">Active</span>`;
                }
                metricsHTML += '</div>';
                
                card.innerHTML = `
                    <div class="fren-header">
                        <img src="${fren.picture || `https://robohash.org/${fren.pubkey}?set=set5`}" 
                             class="fren-avatar" 
                             onerror="this.src='https://robohash.org/${fren.pubkey}?set=set5'">
                        <div class="fren-info">
                            <div class="fren-name">${fren.name}</div>
                            <div class="fren-npub" onclick="copyNpub('${fren.npub}')">${fren.npub.substring(0,20)}...</div>
                        </div>
                        <div class="match-score">${fren.scores.total}%</div>
                    </div>
                    <p class="fren-bio">${fren.about.substring(0, 150)}${fren.about.length > 150 ? '...' : ''}</p>
                    ${metricsHTML}
                    ${hashtags.length > 0 ? `
                        <div class="tags-container">
                            ${hashtags.map(tag => `<span class="tag">#${tag}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="fren-actions">
                        <button class="btn-follow ${fren.isFollowing ? 'following' : ''}" 
                                data-pubkey="${fren.pubkey}"
                                ${!currentUser ? 'disabled' : ''}>
                            ${fren.isFollowing ? 'Following' : 'Follow'}
                        </button>
                        <a href="https://njump.me/${fren.npub}" target="_blank" class="btn-view-profile">View</a>
                    </div>
                `;

                const followBtn = card.querySelector('.btn-follow');
                followBtn.addEventListener('click', async () => {
                    if (fren.isFollowing) return;
                    followBtn.disabled = true;
                    followBtn.textContent = 'Following...';
                    const success = await followUser(fren.pubkey);
                    if (success) {
                        followBtn.textContent = 'Following';
                        followBtn.classList.add('following');
                        fren.isFollowing = true;
                    } else {
                        followBtn.disabled = false;
                        followBtn.textContent = 'Follow';
                    }
                });

                return card;
            }

            // Render results
            function renderResults(profiles) {
                const resultsGrid = document.getElementById('results-grid');
                resultsGrid.innerHTML = '';

                profiles.forEach(fren => {
                    const card = createProfileCard(fren);
                    resultsGrid.appendChild(card);
                });
            }

            // Sort results
            document.getElementById('sort-by').addEventListener('change', function() {
                const currentProfiles = Array.from(document.querySelectorAll('.fren-card')).map(card => {
                    // Extract data from cards - in real app, store profiles globally
                    return null;
                });
                // Implement sorting logic here
            });

            // Main search
            document.getElementById('find-btn').addEventListener('click', async () => {
                const npubInput = document.getElementById('npub-input').value.trim();
                const findBtn = document.getElementById('find-btn');
                const resultsSection = document.getElementById('results-section');
                const emptyState = document.getElementById('empty-state');
                const resultsGrid = document.getElementById('results-grid');

                // Validate hashtag mode
                if (discoveryMode === 'hashtags') {
                    if (selectedHashtags.size === 0) {
                        alert('Please select at least one hashtag to search');
                        return;
                    }
                    console.log('Hashtag discovery mode:', Array.from(selectedHashtags), 'Match mode:', matchMode);
                }

                if (!npubInput) {
                    alert('Please enter your npub or login');
                    return;
                }

                if (!npubInput.startsWith('npub1')) {
                    alert('Invalid npub format');
                    return;
                }

                // Prevent multiple simultaneous searches
                if (findBtn.disabled) {
                    return;
                }

                findBtn.disabled = true;
                findBtn.textContent = 'Discovering...';
                emptyState.style.display = 'none';
                resultsSection.style.display = 'block';
                resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';

                try {
                    const { data: userPubkey } = nip19.decode(npubInput);
                    const userProfile = await fetchProfile(userPubkey);
                    const userFollows = await fetchFollows(userPubkey);
                    
                    let candidatePubkeys;
                    
                    // Use cross-reference data if enabled
                    if (crossRefEnabled && crossRefData) {
                        // Combine all three groups for discovery
                        const allCandidates = [
                            ...crossRefData.youOnly,
                            ...crossRefData.themOnly,
                            ...crossRefData.mutual
                        ];
                        
                        // Remove duplicates and limit
                        candidatePubkeys = Array.from(new Set(allCandidates))
                            .slice(0, parseInt(document.getElementById('result-count').value) * 2);
                        
                        resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Comparing networks...</p>';
                    } else {
                        candidatePubkeys = await getRecommendations(userPubkey, parseInt(document.getElementById('result-count').value));
                        resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Analyzing your network...</p>';
                    }
                    
                    resultsGrid.innerHTML = '<p style="text-align:center;padding:2rem;color:var(--text-secondary)">Calculating match scores...</p>';

                    // Fetch all data in parallel
                    const profilePromises = candidatePubkeys.map(pubkey => fetchProfile(pubkey));
                    const followPromises = candidatePubkeys.map(pubkey => fetchFollows(pubkey));
                    const notePromises = candidatePubkeys.map(pubkey => fetchRecentNotes(pubkey));

                    const [allProfiles, allFollows, allNotes] = await Promise.all([
                        Promise.all(profilePromises),
                        Promise.all(followPromises),
                        Promise.all(notePromises)
                    ]);

                    const profiles = allProfiles
                        .map((profile, idx) => {
                            if (!profile.pubkey) return null;
                            
                            // Spam detection
                            const spamScore = detectSpam(profile, allNotes[idx]);
                            const isNSFW = detectNSFW(profile);
                            
                            const scores = calculateMatchScore(
                                userProfile,
                                profile,
                                userFollows,
                                allFollows[idx],
                                allNotes[idx],
                                discoveryMode === 'hashtags' ? selectedHashtags : null
                            );

                            const mutual = allFollows[idx].filter(f => userFollows.includes(f)).length;

                            // Determine cross-reference category
                            let crossRefCategory = null;
                            if (crossRefEnabled && crossRefData) {
                                if (crossRefData.mutual.includes(profile.pubkey)) {
                                    crossRefCategory = 'mutual';
                                } else if (crossRefData.youOnly.includes(profile.pubkey)) {
                                    crossRefCategory = 'you-only';
                                } else if (crossRefData.themOnly.includes(profile.pubkey)) {
                                    crossRefCategory = 'them-only';
                                }
                            }

                            return {
                                ...profile,
                                npub: nip19.npubEncode(profile.pubkey),
                                scores: scores,
                                mutual: mutual,
                                isFollowing: userFollowing.has(profile.pubkey),
                                spamScore: spamScore,
                                isNSFW: isNSFW,
                                crossRefCategory: crossRefCategory
                            };
                        })
                        .filter(p => {
                            if (!p) return false;
                            
                            // In hashtag mode, filter out profiles with no matching tags
                            if (discoveryMode === 'hashtags' && p.scores.breakdown.hashtag === 0) {
                                return false;
                            }
                            
                            // Apply spam filter
                            const hideSpam = document.getElementById('hide-spam').checked;
                            if (hideSpam && p.spamScore > 60) {
                                console.log('Filtering spam:', p.name, 'Score:', p.spamScore);
                                return false;
                            }
                            
                            // Apply NSFW filter
                            const hideNSFW = document.getElementById('hide-nsfw').checked;
                            if (hideNSFW && p.isNSFW) {
                                console.log('Filtering NSFW:', p.name);
                                return false;
                            }
                            
                            return true;
                        })
                        .sort((a, b) => b.scores.total - a.scores.total)
                        .slice(0, parseInt(document.getElementById('result-count').value));

                    // Separate into new discoveries and already following
                    const hideFollowing = document.getElementById('hide-following').checked;
                    
                    let newProfiles, followingProfiles;
                    
                    if (hideFollowing) {
                        // When hiding, separate them
                        newProfiles = profiles.filter(p => !p.isFollowing);
                        followingProfiles = profiles.filter(p => p.isFollowing);
                    } else {
                        // When showing, put all in main grid
                        newProfiles = profiles;
                        followingProfiles = [];
                    }

                    // Display profiles
                    document.getElementById('results-count').textContent = `${newProfiles.length} matches`;
                    renderResults(newProfiles);

                    // Display already following section if there are any AND hiding is enabled
                    const followingSection = document.getElementById('following-section');
                    const followingGrid = document.getElementById('following-grid');
                    
                    if (followingProfiles.length > 0 && hideFollowing) {
                        followingSection.style.display = 'block';
                        document.getElementById('following-count').textContent = followingProfiles.length;
                        
                        // Render following profiles in separate grid
                        followingGrid.innerHTML = '';
                        followingProfiles.forEach(fren => {
                            const card = createProfileCard(fren);
                            followingGrid.appendChild(card);
                        });
                    } else {
                        followingSection.style.display = 'none';
                    }

                } catch (err) {
                    console.error('Error:', err);
                    resultsGrid.innerHTML = `<p style="text-align:center;padding:2rem;color:var(--accent-primary)">Error: ${err.message}</p>`;
                } finally {
                    findBtn.disabled = false;
                    findBtn.textContent = 'Discover Frens';
                }
            });

            document.getElementById('npub-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('find-btn').click();
            });

            window.copyNpub = (npub) => {
                navigator.clipboard.writeText(npub).then(() => console.log('Copied:', npub));
            };

            // Close bunker modal
            document.getElementById('close-bunker').addEventListener('click', function() {
                document.getElementById('bunker-login-modal').classList.remove('visible');
                if (bunkerAbortController) {
                    bunkerAbortController.abort();
                }
            });

            document.getElementById('bunker-login-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.remove('visible');
                    if (bunkerAbortController) {
                        bunkerAbortController.abort();
                    }
                }
            });

             updateUserUI();
            
    // ============ MAIN APPLICATION END ============
        }); // End: window.addEventListener('load', async function() {
    </script>
</body>
</html>